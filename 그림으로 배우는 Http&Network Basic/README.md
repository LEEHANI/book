# 그림으로 배우는 Http&Network Basic
: 우에노 센 지음

- 목차
  + 1장 TCP/IP, 
  + 2장 stateless, HTTP 메서드, 지속연결, 파이프라인화
  + 

## 제 1장 웹과 네트워크의 기본에 대해 알아보자 
- 클라이언트에서 서버까지 일련의 흐름을 결정하고 있는 것은 HTTP 프로토콜이다. 
- 웹은 지식 공유를 위해 고안되었다. 
- TCP/IP
  - HTTP 등장 당시에 주로 텍스트를 전송하기 위한 프로토콜이었지만, 지금은 웹이라는 틀을 넘어서 다양하게 사용되는 프로토콜이 되었다.
  - HTTP는  TCP/IP 프로토콜에서 움직인다.
  - IP는 복잡한 네트워크 망에서 가장 효율적인 방법으로 데이터를 보내는 일을 한다
  - TCP는 데이터를 잘게 잘라 보낸다. 순서가 맞지 않거나 중간에 빠진 부분을 체크하여 다시 요청을 한다. 
  - TCP/IP는 '애플리케이션 계층', '트랜스포트 계층', '네트워크 계층', '링크 계층'으로 나뉘어져 있다. 
    + 애플리케이션 계층: 송신측 클라이언트의 애플리케이션 계층에서 어느 웹 페이지를 보고 싶다라는 HTTP 리퀘스트를 지시
    + 트랜스포트 계층: 애플리케이션 계층에서 받은 데이터를 통신하기 쉽게 조각내어(패킷) 안내 번호와 포트 번호를 붙여(IP 헤더) 네트워크 계층에 전달
    + 네트워크 계층: 수신지 MAC 주소를 추가해서 링크 계층에 전달 
  - TCP/IP가 계층화되어 있기 때문에 사양이 변경되어도 해당 계층만 바꾸면 되므로 각 계층은 자유룝게 설계할 수 있다.  
  - 상대방에게 전달하기까지 여러 가지 요소가 필요한데, 그중 IP주소와 MAC 주소가 중요한 요소이다. 
  - IP 주소는 각 노드에 부여된 주소를 가리키고 MAC 주소는 각 네트워크 카드에 할당된 고유의 주소이다. 
  - `IP통신은 MAC 주소에 의존하여 통신한다.`
- TCP
  - TCP(Transfer Control Protocol)은 트랜스포트 층에 해당하는데, 신뢰성 있는 바이트 스트림 서비스를 제공한다.
  - `TCP는 대용량의 데이터를 보내기 쉽게 작게 분해하여 상대에게 보내고, 정확하게 도착했는지 확인하는 역할을 담당하고 있다.`
  - TCP는 쓰리웨이 핸드셰이킹 방법을 통해 데이터를 확실하게 보낸다. 
- `DNS(Domain Name System)는 HTTP와 같이 응용 계층 시스템에서 도메인 이름과 IP 주소 이름 확인을 제공한다.`
- HTTP 통신
  - (클라이언트) [HTTP 담당] 웹 서버에 보낼 HTTP 메세지 작성 -> [TCP 담당] 통신하기 수비도록 HTTP 메시ㅔ지를 패킷으로 분해 -> [IP 담당] 상대가 어디에 있는지 찾아 중계해(라우터) 가면서 배송 -> ... -> [IP 담당] 상대방으로부터 패킷을 수신 -> [HTTP 담당] 웹 서버에 대한 리퀘스트 내용을 처리
- URL과 URI
  - URL은 웹 페이지를 표시하기 위해 입력하는 주소이다. 
  - URI는 리소스를 식별하기 위해 문자열 전반을 나타내는데 비해 URL은 리소스의 장소를 나타낸다. 

## 제 2장 간단한 프로토콜 HTTP
- 텍스트와 이미지 등과 같은 리소스를 필요하다고 요구하는 쪽이 클라이언트가 되고, 이러한 리소스를 제공하는 쪽이 서버가 된다. 
  + 클라이언트 측으로부터 통신이 시작된다. 서버 측은 리퀘스트를 받지 않고서는 리스폰스를 송신하는 일이 없다. 
- `HTTP는 상태를 계속 유지하지 않는 stateless 프로토콜이다.`
  + 이전에 보냈던 request나 이미 되돌려준 response에 대해서는 전혀 기억하지 않는다.
  + 많은 데이터를 매우 빠르고 확실하게 처리하는 범위성(scalability)을 확보하기 위해서 이와 같이 간단하게 설계되어 있다.   
  + 서버의 CPU나 메모리 같은 리소스의 소비를 억제할 수 있다. 
- 웹이 진화함에 따라, 로그인 상태를 유지할 필요성이 대두되면서, `쿠키`라는 기술을 도입하여 상태를 계속 유지할 수 있게 되었다.
  + 쿠키는 리퀘스트와 리스폰스에 쿠키 정보를 추가해서 클라이언트의 상태를 파악하기 위한 시스템이다. 
- `HTTP/1.1은 상태를 유지하지 않는 프로토콜이다.` 
- HTTP 메서드 
  + `GET`: 리소스 획득 
  + `POST`: 엔티티 전송
  + `PUT`: 파일 전송
    - HTTP/1.1 PUT 자체에는 인증 기능이 없어 누구든지 파일을 업로드 가능하다는 보안 상의 문제가 있어 일반적인 웹 사이트에서는 사용되지 않는다.
    - 웹 애플리케이션 등에 의한 인증 기능과 짝을 이루는 경우나 REST와 같이 웹끼리 연계하는 설계 양식을 사용할 때 이용하는 경우도 있다. 
  + `HEAD`: 메시지 헤더 취득  
    - GET과 같은 기능이지만 메시지 바디는 돌려주지 않는다. 
  + `DELETE`: 파일 삭제
    - HTTP/1.1 DELETE 자체에는 PUT 메소드와 같이 인증 기능이 없기 때문에 일반적인 웹 사이트에서는 사용되지 않는다.
    - 웹 애플리케이션 등에 의한 인증 기능과 짝을 이루는 경우나 REST와 같이 웹끼리 연계하는 설계 양식을 사용할 때 이용하는 경우도 있다.   
  + `OPTIONS`: request URI로 지정한 리소스가 제공하고 있는 메소드를 문의 
  + TRACE: 경로 조사 
    - TRACE 메소드는 거의 사용되지 않는다. 
    - 크로스 사이트 트레이싱(XST)과 같은 공격을 일으키는 보안 상의 문제도 있기 떄문에 보통은 사용되지 않는다.
  + CONNECT: 프록시에 터널링 요구 
- `HTTP 초기 버전에서는 HTTP 통신을 한 번 할때마다 TCP에 의해 연결과 종료를 해야했다.` 
  + 초기 통신에서는 작은 사이즈의 텍스트를 보냈기 때문에 문제가 없었지만, 하나의 HTML에 여러 이미지가 있을 경우 매번 TCP 연결과 종료를 하게 되면서 통신량이 늘어나게 되었다.
- TCP 연결 문제를 해결하기 위해 어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상 TCP 연결을 계속 유지하는 `지속 연결(Persistent Connections)` 방법이 생겼다.  
  + HTTP/1.1에서는 표준 동작이지만 HTTP/1.0에서는 정식 사양이 아니다.
- 지속 연결은 여러 리퀘스트를 보낼 수 있도록 파이프라인화를 가능하게 하는데, `파이프라인화`에 의해서 이전에는 리퀘스트 송신 후에 리스폰스를 수신할 때까지 기다린 뒤에 리퀘스트를 발행해던 것을, 리스폰스를 기다리지 않고 바로 다음 리퀘스트를 보낼 수 있다.   

## 제 3장 HTTP 정보는 HTTP 메시지에 있다. 
- HTTP 메시지는 `메시지 헤더`와 `메시지 바디`로 구분되어 있고, 최초로 나타나는 `개행 문자(CR+LF)`로 메시지 헤더와 메시지 바디를 구분한다.
  ```
  [메시지 헤더]
  개행문자
  [메시지 헤더]
  ```
- 메시지 헤더 내부는 리퀘스트/상태 라인, 리퀘스트/리스폰스 헤더 필드, 일반 헤더 필드, 엔티티 헤더 필드, 그 외(쿠키 필드)로 구성되어 있다. 
- HTTP 데이터를 전송할 때 인코딩을 실시하면 전송 효율을 높일 수 있다. 
  + 대신 CPU 등의 리소스를 많이 소비한다.
- HTTP의 `콘텐츠 코딩(Content Codings)`라는 기능을 사용하면 zip과 같은 압축 파일을 첨부할 수 있다. 
- 사이즈가 큰 데이터를 분할해서 조금씩 보낼 수 있는데, 이렇게 바디를 분할하는 기능을 `청크 전송 코딩(Chunked transfer Coding)`이라 부른다. 
  + 기존에는 엔티티 바디의 전송이 완료되지 않으면 브라우저에 표시되지 않았다.
  + 청크 전송 코딩을 이용하면 데이터를 분할해서 조금씩 표시할 수 있다.
- 멀티파트
  - 멀티파트는 파트마다 헤더 필드가 포함된다.
  - 멀티파트 각각의 엔티티를 구분하기 위해 `bounday` 문자열을 사용한다. 
  - HTTP에서는 `multipart/form-data`로 하나의 메시지 바디 내부에 여러 개의 엔티티를 포함시켜 보낼 수 있다.  
    ```
    Content-Type: multipart/form-data boundary=AaB03x
    --AaB03x
    Content-DispositionL form-data; name="f1"
    visual
    --AaB03X
    Content-DispositionL form-data; name="f1.txt"
    visual
    --AaB03X--
    ```
  - HTTP에서는 `multipart/byteranges`로 response 메시지에 복수 범위의 내용을 포함시켜 보낼 수 있다. 상태 코드 `206 Partial Content`로 들어온다. 
    + 기존에는 대용량의 데이터를 다운로드 중에 커넥션이 끊어지게 되면 처음부터 다시 다운로드를 했었다.
    + 이전에 다운로드를 한 곳에서부터 다운로드를 재개할 수 있도록 `리줌(resume)`이라는 기능을 제공한다. 리줌 덕분에 엔티티 범위를 지정해서 다운로드 하는 레인지 리퀘스트를 할 수 있다. 
    ```
    HTTP/1.1 206 Partial Content
    Date: ...
    Last-Modified: ...
    Content-Type: multipart/byteranges: boundary=THIS_STRING_SEPARATES
    --THIS_STRING_SEPARATES
    Content-Type: application/pdf
    Content-Range: bytes 500-900/5000
    --THIS_STRING_SEPARATES
    Content-Type: application/pdf
    Content-Range: bytes 4000-4900/5000
    --THIS_STRING_SEPARATES--
    ```  
- 언어에 따라 알맞은 웹 페이지를 표시하는 구조를 콘텐츠 네고시에이션(Content Negotiation)이라 한다. 언어와 문자 세트, 인코딩 방식 등을 기준으로 리소스를 제공한다.
  + 서버 구동형 네고시에이션: 서버 측에서 콘텐츠 네고시에이션을 수행한다. 주로 리퀘스트의 헤더 정보를 참고해서 자동적으로 처리한다. 
  + 에이전트 구동형 네고시에이션 : 클라이언트 측에서 수동으로 언어를 선택한다.
  + 트랜스페이런트(투명한) 네고시에이션 : 서버와 클라이언트 각각 네고시에이션을 수행한다.

## 제 4장 결과를 전달하는 HTTP 상태 코드
- 서버는 클라이언트가 보낸 리퀘스트 결과를 `상태 코드`로 알려준다. 
- `1xx` `Informational` 처리중
- `2xx` `Success` 정상 처리 했음
  + 200 OK: 정상 처리
  + 204 No Content: 처리는 성공했지만 돌려줄 리소스가 없음
  + 206 Partial Content: Range Request 처리
- `3xx` `Redirection` 추가 동작 필요 
  + 301 Moved Permanently: 요청한 URI가 다른 URI로 변경되었음을 알리며, 변경된 URI로 redirect 처리
  + 302 Found: 요청한 URI가 다른 URI로 임시 변경되었음을 알리며, 변경된 URI로 redirect 처리
  + 303 See Other: POST 메소드로 처리 한 결과를 별도의 URI의 GET 메소드로 redirecet 처리
  + 304 Not Modified: 리소스에 대한 액세스는 허락하지만, 조건이 충족되지 않음을 의미. Response Body에 어떤 데이터도 포함되어 있지 않는다
  + 307 Temporary Redirect:    
- `4xx` `Cilent Error` 
  + 400 Bad Request: request 구문이 잘못되었음을 의미 
  + 401 Unauthorized: HTTP 인증 정보가 필요 or 인증 실패
  + 403 Forbidden: 액세스 권한이 없어서 거부 되었음을 의미 
  + 404 Not FOund: 서버에 없는 리소스를 의미
- `5xx` `Server Error` 
  + 500 Internal Server Error: 서버에서 request를 처리하는 도중 에러가 발생
  + 503 Service Unavaliable: 일시적으로 서버가 과부하 상태이거나 점검중이기 때문에 request를 처리할 수 없음을 의미

## 제 5장 HTTP와 연계하는 웹 서버 
- HTTP/1.1에서는 하나의 HTTP 서버에 `가상 호스트(Virtual Host)`를 둬서 여러 개의 웹 사이트를 실행할 수 있다. 
- 같은 IP 주소에서 다른 호스트명과 도메인 명을 가진 여러 개의 웹 사이트가 실행되고 있는 가상 호스트의 시스템이 있기 때문에, HTTP request를 보내는 경우에는 호스트명과 도메인 명을 완전하게 포함한 URI를 지정하거나, 반드시 Host 헤더 필드에서 지정해야 한다. 
- `프록시(Proxy)`
  - `프록시 서버는 서버와 클라이언트 중간에 위치하여 클라이언트의 리퀘스트를 서버에 전송하고, 서버로부터 받은 리스폰스를 클라이언트에게 전달한다.`
  - `캐시`를 사용해 네트워크 대역을 효율적으로 사용하거나 특정 웹 사이트에 대한 `액세스 제한, 액세스 로그를 획득`하려는 목적으로 사용된다. 
  + `캐싱 프록시`: `프록시 서버 상에 리소스 캐시(리소스 사본)를 보존하여 오리진 서버로부터 리소스를 획득하는 것이 아니라 캐시를 response로 돌려준다.` 캐시를 가지고 있더라도 클라이언트의 요구나 캐시의 유효 기간 등에 의해서 오리진 서버에 리소스의 유효성을 확인하거나 새로운 리소스를 다시 획득하러 가게 되는 경우가 있다. 
  + 투명 프록시: request와 response를 중계 할 때 메시지를 변경하지 않는 타입이다. <-> 비투과 프록시
- `게이트웨이(Gateway)`
  + 다른 서버를 중계하는 서버로, 클라이언트로부터 수신한 리퀘스트를 리소스를 보유한 서버인 것처럼 수신한다. HTTP 프로토콜 이외의 서버와 통신 서비스를 제공한다. 클라이언트와 게이트웨이 사이를 암호화하여 통신의 안전성을 높여준다. 
- `터널(Tunnel)` 
  + 터널을 사용하면 클라이언트는 서버와 SSL 같은 암호화 방법으로 안전하게 통신할 수 있다. 
- `캐시는 클라이언트가 사용하고 있는 부라우저에서도 캐시를 가질 수 있다. 클라이언트가 보존하는 캐시를 인터넷 임시 파일이라 부른다.` 

## 제 6장 HTTP 헤더 

#### HTTP/1.1 일반 헤더 필드 

###### Cache-Control: 캐싱 동작 지정 
`Cache-Control: private, max-age=0, no-cache`
- Cache-Control request
  + `Cache-Control: no-cache`: 캐시가 있더라도 항상 오리진 리소스를 요청한다.
  + `Cache-Control: no-store`: 기밀 정보가 포함되어 있으므로 캐시의 일부분을 보존해서는 안된다.
  + `Cache-Control: max-age=604800(초)`: 최대 Age 값
  + `Cache-Control: max-state=3600`: 캐시의 유효기간이 만료된지 3600초 이내라면, 리소스 캐시를 받아들이겠다는 의미이다. 
  + `Cache-Control: min-fresh=60`: 캐시가 앞으로 60초 이상 유효하다면, 리소스 캐시를 받아들이겠다는 의미이다. 
  + `Cache-Control: no-transform`: response body의 미디어 타입을 변경하지 않도록 지정한다. 캐시 서버 등에 의해서 이미지가 압축되는 것을 방지하기 위해
  + `Cache-Control: only-if-cached`: 캐시 서버에 캐시가 있는 경우만 반환하고, 그렇지 않으면 504 Gateway Timeout을 반환한다. 
- Cache-Control response
  + `Cache-Control: public`: 어떤 유저에게도 캐시를 돌려줘도 좋다
  + `Cache-Control: private`: 특정 유저만 캐시로 반환하고, 다른 유저는 캐시를 반환하지 않도록한다. 
  + `Cache-Control: no-cache`: 캐시 서버는 리소스를 저장할 수 없다.  
  + `Cache-Control: no-store`: 기밀 정보가 포함되어 있으므로 캐시의 일부분을 보존해서는 안된다.
  + `Cache-Control: no-transform`: response body의 미디어 타입을 변경하지 않도록 지정한다. 캐시 서버 등에 의해서 이미지가 압축되는 것을 방지하기 위해
  + `Cache-Control: must-revalidate`: 캐시가  현재도 유효한지 아닌지 오리진 서버에 리소스의 재확인을 요구한다. 
  + `Cache-Control: proxy-revalidate`: 중간 캐시 서버에서 캐시를 반환할 때 캐시 유효성의 재확인을 요구한다. 
  + `Cache-Control: max-age=604800(초)`: 최대 Age 값
  + `Cache-Control: s-maxage=604800(초)`: 공유 캐시 서버의 최대 Age 값 

###### Connection: Hop-by-hop 헤더, 커넥션 관리 
- 프록시에 더 이상 전송하지 않는 헤더 필드(hop-by-hop 헤더)를 지정
- 지속적 접속관리 
  + `Connection: Close`: 지속적 접속을 서버 측에서 명시적으로 접속을 끊고 싶을 경우에 사용한다.
  + `Connection: Keep-Alive`: HTTP/1.1 이전 버전은 지속적 접속이 디폴트가 아니기 때문에, 지속적 접속을 하고 싶은 경우 지정해줘야 한다. 

###### Date: 메시지 생성 날짜 
- `Date: Tue, 03 Jul 2012 04:40:68 GMT`

###### Pragma: 메시지 제어 
- HTTP/1.0 버전과 호환성을 위해서 정의되어 있는 헤더 필드이다.
- 중간 서버의 HTTP 버전에 HTTP/1.0이 있을 수 있으므로 캐시 동작 지정을 아래와 같이 양쪽으로 보내는 경우도 있다. 
  ```
  Cache-Control: no-cache
  Pragma: no=cache 
  ```

###### Trailer: 메시지의 끝에 있는 헤더의 알람 
```
...
Transfer-Encoding: chunked
Trailer: Expires 
...(메시지 바디)...
0
Expires: Tue, 28 Sep 2004 23:5959 GMT
```
- 메시지 바디의 뒤에 기술되어 있는 헤더 필드를 미리 전달 할 수 있습니다. 반드시 `청크 전송 인코딩`을 사용하고 있는 경우에 사용 가능하다.

###### Transfer-Encoding: 메시지 바디의 전송 코딩 형식 지정 
`Transfer-Encoding: chunked`
- 메시지 바디의 전송 코딩 형식을 지정하는 경우에 사용한다. HTTP/1.1에는 `chuncked`만 지정이 가능하다.

###### Upgrade: 다른 프로토콜에 업그레이드 
- HTTP 및 다른 프로토콜의 새로운 버전이 통신에 사용되는 경우에 사용합니다.

###### Via: 프록시 서버에 관한 정보 
- 프록시 혹은 게이트웨이가 자신의 `경로`를 알리기 위해 Via 헤더에 추가한다. 
- 메시지의 추적과 리퀘스트 루프의 회피 등에 사용된다. 

###### Warning: 에러 통지 
- 리스폰스에 관한 추가 정보를 전달합니다. 기본적으로 캐시에 관한 문제의 경고 를 유저에 전달한다.

#### HTTP/1.1 리퀘스트 헤더 필드 

###### Accept: 유저 에이전트가 처리 가능한 미디어 타입
`Accept: text/html, application/xhtml+xml,application/xml;q=0.9,*/*,q=0.8`
- 유저 에이전트에 처리할 수 있는 미디어 타입과 미디어 타입의 상대적인 우선 순위를 전달하기 위해서 사용된다. 
- 표시하는 미디어 타입에 `우선 순위`를 붙이고 싶을 경우에는 세미콜론 ";"으로 구분하고 "q="로 표시할 `품질 지수`를 더한다. 품질 계수의 디폴트 값은 1.0이다. 

###### Accept-Charset: 문자셋 우선 순위 
`Accept-Charset: iso-8859-5, unicode-1-1:q+0.8`
- 유저 에이전트에서 처리할 수 있는 문자셋으로, 문자셋의 상대적인 우선 순위를 전달하기 위해 사용된다. 
- 서버 구동형 네고시에이션에서 이용

###### Accept-Encoding: 콘텐츠 인코딩 우선 순위 
`Accept-Encoding: gzip, deflate`
- 유저 에이전트가 처리할 수 있는 콘텐츠 코딩과 콘텐츠 코딩의 상대적인 우선 순위를 전달하기 위해 사용된다. 

###### Accept-Language: 언어 우선 순위 
`Accept-Language: ko-kr, en-us;q=0.7,en;q=0.3`
- 유저 에이전트가 처리할 수 있는 자연어의 세트(한국어+영어)와 자연어 세트의 상대적인 우선 순위를 전달하기 위해 사용 

###### Authorization: 웹 인증을 위한 정보 
`Authorization: Basic dWVub3NlbjpwYXNzd29yZA==`
- 유저 에이전트의 인증 정보를 전달하기 위해 사용

###### Expect: 서버에 대한 특정 동작의 기대 
`Expect: 100-continue`
- 클라이언트가 서버에 특정 동작 요구를 전달한다.

###### From: 유저의 메일 주소 
`From: info@hackr.jp`
- 유저 에이전트를 사용하고 있는 유저의 메일 주소를 전달한다. (경우에 따라 User-Agent 헤더 필드도 사용함)

###### Host: 요구된 리소스의 호스트 
`Host: www.hackr.jp`
-  Host 헤더 필드는 리퀘스트한 리소스의 인터넷 호스트와 포트번호를 전달한다. Host 헤더 필드는 HTTP/1.1에서 유일한 필수 헤더 필드이다. 서버에 Host 명이 없는 경우 비워서 전송한다.

###### If-Match: 엔티티 태그의 비교 
`If-Match: "123456"`
- 요청한 리소스의 엔티티태그가 "123456"인 경우에만 리퀘스트를 받는다. 아닌 경우에는 412 Precondition Failed를 전달한다.

###### If-Modified-Since: 리소스의 갱신 시간 비교 
`If-Modified-Since : Thu, 15 Apr 2004 00:00:00 GMT`
- 리소스가 2004년 4월 15일 이후에 갱신되었다면 리퀘스트를 받는다. 아닌 경우에는 304 Not Modified를 전달한다. 

###### If-None-Match: 엔티티 태그의 비교(If-Match의 반대)
- 지정된 값이 일치하지 않으면 리퀘스트를 받는다. 

###### If-Range: 리소스가 생신되지 않은 경우에 엔티티의 바이트 범위의 요구를 송신 
`If-Range : "123456" Range: byte=5001-10000`
- 리소스의 엔티티 태그가 "123456"이면 서버는 요청한 5000 바이트만 전송한다. 

###### If-Unmodified-Since: 리소스의 갱신 시간 비교(If-Modified-Since의 반대)
- 지정된 리소스가 필드 값에 지정된 날짜 이후에 갱신되어 있지 않는 경우에만 리퀘스트를 받는다.

###### Max-Forwards: 최대 전송 홉수 
`Max-forwards: 10`
- TRACE 혹은 OPTIONS 메소드에 의한 리퀘스트를 할 때에 전송해도 좋은 서버 수의 최대치를 10진수 정수로 지정한다. 
- 서버는 다음 서버에 리퀘스트를 전송할 때는 값에서 1을 빼서 다시 세트한다. Max-Forwards 값이 0이로 바뀐 서버는 response를 반환한다.
- 필드 값이 0이 되었던 서버가 response를 하기 때문에 그 서버까지의 상황을 알 수 있다. 

###### Proxy-Authorization: 프록시 서버의 클라이언트 인증을 위한 정보 
`Proxy-Authorization : Basic dGlwOjkpNLAGfFY5`
- 클라이언트와 서버의 HTTP 엑세스 인증과 비슷한데 다른 점은 클라이언트와 프록시 사이에 인증이 이루어진다.

###### Range: 엔티티 바이트 범위 요구 
`Range : byte=5001-10000`
- 리소스의 일부분만 취득하는 Range request를 할 때 지정범위이다.

###### Referer: 리퀘스트중의 URI를 취득하는 곳
`Referer : http://www.hackr.jp/index.html`
- 현재 보내고 있는 리퀘스트를 어느 웹 페이지에서부터 발행되었는지를 전달한다. 보안상 바람직하지 않다고 판단되는 경우는 보내지 않아도 된다.

###### TE: 전송 인코딩의 우선 순위
`TE: gzip, deflate;q=0.5`
- response로 받을 수 있는 전송 코딩의 형식과 상대적인 우선 순위를 전달한다. 

###### User-Agent: HTTP 클라이언트의 정보 
`User-Agent:Mozila/5.0(Windows NT 6.1) AppleWebKit/535.19 ...`
- 리퀘스트를 생성한 브라우저와 유저 에이전트의 이름 등을 전달하기 위한 필드이다.

#### HTTP/1.1 리스폰스 헤더 필드 

###### Accept-Ranges: 바이트 단위의 요구를 수신할 수 있는지 없는지 여부
`Accept-Ranges: bytes`
- 서버가 리소스의 일부분만 전송하는 것에 동의하면 bytes 불가능한 경우에는 none을 전달한다. 

###### Age: 유저 에이전트가 처리 가능한 미디어 타입
`Age: 600`
- 얼마나 오래 전에 오리진 서버에서 response가 생성되었는지를 전달 

###### ETag: 유저 에이전트가 처리 가능한 미디어 타입
`ETag: "82e222293907...`
- 엔티티 태그라고 불리며 일의적으로 리소스를 특정하기 위한 문자열을 전달한다. 서버는 리소스마다 ETag 값을 할당한다.

###### Location: 유저 에이전트가 처리 가능한 미디어 타입
`Location: http://www.usagidesign.jp/sample.html`
- 대부분의 브라우저에서는 Location 헤더 필드를 포함한 response를 받으면 강제로 리다이렉트 하는 곳의 리소스에 액세스를 시도한다. 

###### Proxy-Authenticate: 유저 에이전트가 처리 가능한 미디어 타입
`Proxy-Authenticate: Basic realm="Usagidesign Auth`
- 클라이언트와 프록시 사이에서 인증이 이루어진다.

###### Retry-After: 유저 에이전트가 처리 가능한 미디어 타입
`Retry-After: 120`
- 클라이언트가 일정 시간 후에 리퀘스트를 다시 시행해야 하는지를 전달한다. 

###### Server: 유저 에이전트가 처리 가능한 미디어 타입
`Server: Apache/2.2.17(Unix)`
- 서버에 설치되어 있는 HTTP 서버의 소프트웨어를 전달한다.

###### Vary: 유저 에이전트가 처리 가능한 미디어 타입
`Vary: Accept-Language`
- 캐시를 컨트롤하기 위해서 사용한다. Vary에 지정되어 있는 헤더 필드를 가진 request에 대해서만 캐시를 반환할 수 있다. 

###### WWW-Authenticate: 유저 에이전트가 처리 가능한 미디어 타입
`WWW-Authenticate: Basic realm="Usagidesign Auth`
- HTTP 엑세스 인증에 사용되는데 Request-URI에 지정했던 리소스에 적용할 수 있는 인증 스키마와 파라미터를 나타내는 challenge를 전달한다. 

## 제7장 웹을 안전하게 지켜주는 HTTPS
### HTTP의 약점 
- `평문`(암호화 하지 않은) 통신이기 때문에 `도청` 가능
- 통신 상대를 확인하지 않기 떄문에 `위장` 가능
- 완전성을 증명할 수 없기 때문에 `변조` 가능

#### 평문이기 때문에 도청 가능 
- TCP/IP는 통신 내용을 전부 통신 경로의 도중에 엿볼 수 있다.  
- 네트워크 상에서 흐르고 있는 패킷을 수집하는 것만으로 도청할 수 있다. 
- 해결
  1. 통신 암호화 
      - SSL이나 TLS 프로토콜을 조합하여 HTTP 통신 내용을 암호화할 수 있다. 
      - SSL 을 조합한 HTTP 를 HTTPS(HTTP Secure) or HTTP over SSL이라 한다. 
  2. 콘텐츠 암호화 
      + HTTP 메시지에 포함되는 콘텐츠에만 암호화를 한다. 

#### 통신 상대를 확인하지 않기 때문에 위장 가능 
- HTTP에 의한 통신에는 상대가 누구인지 확인하는 처리는 없기 떄문에 누구든지 리퀘스트를 보낼 수 있기 때문에 대량의 request에 의한 DoS 공격을 방지할 수가 없다. 
- 해결
  - HTTP에서는 통신 상대를 확인할 수 없지만 SSL로 상대를 확인할 수 있다. `SSL은 암호화뿐만 아니라 상대를 확인하는 수단으로 증명서를 제공하고 있다.` 
  - `증명서는 신뢰할 수 있는 제3자 기관에 의해 발행되는 것이기 때문에 서버나 클라이언트가 실재하는 사실을 증명한다.`

#### 완전성을 증명할 수 없기 때문에 변조 가능 
- request나 response가 발신된 후에 상대가 수신할 때까지의 사이에 변조되었다고 하더라도 이 사실을 알 수 없다. 
- 공격자가 도중에 request나 response를 빼앗아 변조하는 공격을 `중간자 공격(Man-in-the-middle-attack)`이라고 부른다. 
- 해결
  + MD5, SHA-1 등의 해시 값을 확인하는 방법과 파일의 디지털 서명을 확인하는 방법이 존재하지만 확실히 확인할 수 있는 것은 아니다. 확실히 방지하기에는 `HTTPS`를 사용해야 한다.

### HTTP + 암호화 + 인증 + 변조 보호 = HTTPS
- HTTPS는 HTTP통신을 하는 `소켓 부분`을 `SSL(Secure Socket Layer)`이나 `TLS(Transport Layer Security)`이라는 프로토콜로 대체한 것이다.
- SSL을 사용함으로써 HTTP는 HTTPS로서 `암호화`, `증명서`, `완전성 보호`를 이용할 수 있다.  
- HTTPS는 키를 교호나하는 곳에서는 `공개키 암호`를 사용하고 그 후의 통신에서 메시지를 교환하는 곳에서는 `공통키 암호`를 사용한다. 
- 서버가 발행한 공개키인지 증명하기 위해 인증 기관이 존재하고, 인증 기관에서 공개키 증명서를 발행해 준다. 
- 인증 기관(CA)이란 클라이언트와 서버가 모두 신뢰하는 제3자 기관이다. 

### 공개키가 정확한지 아닌지를 증명하는 증명서 
- 증명서로 인해 서버의 공개키를 인증할 수 있다. 

#### 인증기관 
1. 웹 서버가 자신의 공개키를 CA에게 제출한다. 
2. CA의 비밀키(개인키)로 서버의 공개키를 암호화한 인증서를 서버에게 돌려준다. 
3. 클라이언트의 요청이 발생하면, 서버는 인증서를 전달한다. 
4. 증명서를 받은 클라이언트는 브라우저 내에 내장되어있는 공개키로 증명서를 복호화한다. 복호화하면 웹 서버의 공개키를 얻을 수 있다. 

### HTTPS 과정
1. 서버는 자신의 공개키와 개인키를 발급한다. 
2. 웹 서버는 발급한 공개키를 CA(인증기관)에게 전달하여 인증서 발급을 요청한다.
3. CA는 자신의 개인키로 웹 서버의 공개키를 암호화(디지털서명)하여 웹 서버에게 전달한다. (인증서 발급)
4. 클라이언트는 SSL 통신을 위해 서버에게 Client Hello(SSL Version/Cipher Suite) 메시지를 송신한다.
5. 서버는 자신이 사용할 수 있는 SSL Version과 Cipher Suite를 선택하여 Server Hello 메시지를 송신한다.
6. 서버는 추가적으로 위에서 발급받은 인증서를 클라이언트에게 전달한다.
7. 서버는 Server Hello Done 메시지를 송신하여 최초의 SSL 네고시에이션이 끝났음을 통지한다.
8. 클라이언트는 자신의 브라우저의 CA 리스트에서 인증서에 적힌 CA를 찾고, CA 공개키를 확인한다.
9. 클라이언트는 CA의 공개키로 인증서를 복호화하여 웹 서버의 공개키를 획득할 수 있다.
10. 클라이언트는 Client Key Exchange 메시지를 서버에 전달합니다. 여기에는 Pre-master secret이라는 난수가 포함되어 있다.
11. 클라이언트는 Change Cipher Spec 메시지를 송신합니다. 이 메시지 이후에는 암호키를 사용해서 통신한다는 의미이다.
12. 클라이언트는 Finished 메시지를 송신합니다. 이 메시지는 암호화되어 있다.
13. 서버에서도 마찬가지로 Change Cipher Spec 메시지를 송신한다.
14. 서버에서도 Finished 메시지를 송신한다.
15. 서버와 클라이언트의 Finished 메시지가 서로 교환이 완료되면 SSL 접속이 확립된다.
16. 서버와 클라이언트는 앞서 선택한 대칭키 암호 스펙과 Pre-master secret에서 생성된 master secret으로 암호화 통신을 진행한다.
17. 접속을 끊었을 때에는 close_notify 메시지를 송신하고 그 이후에는 TCP 4 way handshake을 통해 연결을 해제한다.

## 제 8장 누가 액세스하고 있는지를 확인하는 인증 
- 서버에 액세스하고 있는 사람이 누구인지, 본인인지 아닌지를 확인하기 위해 [등록된 본인만이 알고 있는 정보]나 [등록한 본인만이 가지고 있는 정보] 등으로 확인해야한다. 

### BASIC 인증 
- HTTP/1.0에 구현된 인증 방식으로 현재도 일부 사용 중이다.
- 인증 수순 
  - request 
    ```
    GET /private/HTTP/1.1 Host:hackr.jp
    ```
  - 상태 코드 401로 응답해서 인증이 필요하다는 것을 전달  
    ```
    HTTP/1.1 401 Aunthorization Required  
    date: ...
    Server: ...
    WWW-Authenticate Basic realm="Input Your ID and Password"
    ```
  - 유저ID와 패스워드를 Base64 형식으로 인코드 한 것을 송신
    ```
    GET /private/HTTTP/1.1
    Host: hackr.jp
    Authorization: Basic Z3Vic3Q6Zviq3==
    ```  
  - 인증 성공 했을 시 200으로 응답, 실패했을 시 401로 응답
    ```
    HTTP/1.1 200 OK
    Date: ...
    Server: ...
    ```  
- 문제점
  - BASIC 인증에서는 Base64라는 인코딩 형식을 사용하는데 이것은 암호화가 아니기 때문에 통신 경로 상에서 복호화된 유저 ID와 패스워트를 빼앗길 가능성이 있다.
  - 한번 BASIC 인증을 하면, 일반 브라우저에서는 로그아웃할 수 없다.
- BASCI 인증은 사용상의 문제와 많은 웹 사이트에서 요구되는 보안 등급에 미치지 못한다는 면에서 `그다지 사용되고 있지 않다.`

### DIGEST 인증 
- BASIC 인증의 약점을 보안한 방식이다.
- 인증 수순 
  - request 
    ```
    GET /private/HTTP/1.1 Host:hackr.jp
    ```
  - 상태 코드 401로 응답해서 인증이 필요하다는 것을 전달하면서 패스워드와 챌린지 코드(nonce)를 송신 
    ```
    HTTP/1.1 401 Aunthorization Required  
    WWW-Authenticate DIGEST realm="DIGEST", nonce="MOSQZ0..., algorithm=MD5, qop="auth"
    ```
  - 패스워드 문자열을 MD5로 계산해 리스폰스 코드로 송신
    ```
    GET /digest/HTTP/1.1  
    WWW-Authenticate DIGEST realm="DIGEST", nonce="MOSQZ0..., uri="/digest/", algorithm=MD5, response="df563709agaw...", qop="auth" ...
    ```
  - 인증 성공 했을 시 200으로 응답, 실패했을 시 401로 응답
    ```
    HTTP/1.1 200 OK
    Authentication-Info:
    ...
    ```
- BASIC 인증보다 보인 등급은 높지만, 사용상의 문제와 많은 웹 사이트에서 요구되는 보안 등급에는 미치지 못한다는 점에서 `그다지 사용되고 있지 않다.`
- 패스워드의 도청을 방지하기 위한 보호 기능은 제공하고 있지만 위장은 방지하지 못한다.

 ### SSL 클라이언트 인증(공인인증서)
- SSL 클라이언트 인증은 HTTPS의 클라이언트 인증서를 이용한 인증 방식이다. 
- 인증 수순      
  + 사전에 클라이언트에 클라이언트 증명서를 배포하고 인스톨 해둘 필요가 있다. 
  + 인증이 필요한 리소스의 request가 발생 시 서버는 클라이언트에게 Certificate Request 메시지를 송신한다. 
  + 유저가 클라이언트 증명서를 선택하면 클라이언트는 Client Certificate 메시지를 보낸다
  + 서버는 클라이언트 증명서가 정확하다면 클라이언트 공개키를 취득하여 HTTPS에 의한 암호를 개시한다.
- SSL클라이언트 인증은 대부분 폼 베이스 인증(아이디, 비밀번호)과 합쳐서 `2-factor`인증의 하나로서 이용된다. 
- SSL 클라이언트 인증은 클라이언트 증명서를 구입하는 비용과 서버 운영자가 안전하게 운용하기 위한 `비용`이 발생한다. 

### 폼 베이스 인증
- HTTP 프로토콜에 정의되어 있는 인증은 아니다. 클라이언트가 서버 상의 웹 애플리케이션에 자격(Credential)를 송신하여 그 자격 정보의 검증 결과에 따라 인증하는 방식이다. 
  + 웹 애플리케이션 등에 의해서 클라이언트가 request한 유저 ID와 패스워드가 서전에 등록하고 있는 것과 일치하는지 어떤지를 검증하는 방식
- `대부분은 폼 베이스 인증을 사용하지만, 공통 사양이 결정되어 있지 않아서 웹 사이트 별로 다르게 구현을 하고 있다.` 
- `HTTP는 stateless 프로토콜 이기 때문에 일반적으로 세션ID를 쿠키로 발급받아 현재 로그인 상태를 유지한다.`
- 인증 수순
  + 클라이언트가 유저 ID나 패스워드 등의 자격 정보를 서버에게 보낸다. 
  + 서버 측은 유저를 식별하기 위해서 세션 ID를 발행하고 서버 측에 기록한다. Set-Cookie 헤더 필드에 세션 ID를 저장해서 response를 반환한다. 
  + 서버 측에서 세션 ID를 받은 클라이언트는 쿠키로 저장해 둔다.
- 서버에서 패스워드 등의 자격 정보를 어떻게 보존해야 하는 지에 대한 기준은 없지만, 보통 `salt`라는 부가정보를 사용해서 해시 알고리즘된 결과 값을 저장한다.     

## 제 9장 HTTP에 기능을 추가한 프로토콜
- HTTP는 시대를 거치면서 

### SPDY
- `스피디`는 웹 페이지 로딩 시간을 50% 단축한다는 목표로 구글에서 개발되고 있다.
- SNS에서 정보를 거의 실시간으로 보여지는 것이 핵심이 되면서 단시간에 대량의 갱신정보가 서버와 클라이언트에 발생한다. 이로 인해 리퀘스트/리스폰스 헤더를 `압축`하지 않아서 `지연`이 발생하고, 매번 같은 헤더를 보내 `낭비`가 발생한다.   
- 해결법
  + `Ajax`
    - Ajax(Asynchronous JavaScript XML)의 약자로 JavaScript나 DOM 조작 등을 활용하는 방식으로, 웹 페이지의 일부분만 고쳐쓸 수 있는 비동기 통신 방법이다.
    - 웹 사이트의 일부분을 바꿀 수 있어 효율적이지만, Ajax를 이용해 실시간으로 서버에서 정보를 취득하려는 경우에는 대량의 리퀘스트가 발생한다. 
  + `Comet`
    - Comet는 서버 측의 콘텐츠에 갱신이 있었을 경우, 클라이언트로부터 리퀘스트를 기다리지 않고 클라이언트에 보내는 방법이다. 리스폰스를 보류 상태로 해두고, 서버의 콘텐츠가 갱신되었을 때 리스폰스를 반환한다. 
    - 콘텐츠를 실시간으로 갱신할 수는 있지만 리스폰스를 보류하기 위해서 커넥션을 유지하는 시간이 길어진다. 
- Ajax와 Comet 등으로 어느 정도 개선되었지만, 근본적인 문제 개선을 위해 TCP/IP의 애플리케이션 계층과 트랜스포트 계층 사이에 새로운 `세션 계층`을 추가하여 동작하게 되었다. 또한, 표준으로 SSL을 사용한다. 
- SPDY 기능 
  + `다중화 스트림`: 단일 TCP 접속을 통해서 복수의 HTTP 리퀘스트를 무제한으로 처리할 수 있다. 
  + `리퀘스트의 우선 순위 부여`: 리퀘스트에 우선순위 할당 가능하다.
  + `HTTP 헤더 압축`: request와 response의 HTTP 헤더를 압축한다.
  + `서버 푸시 기능`: 서버에서 클라이언트로 데이터를 푸쉬하는 서버 푸시 기능을 지원한다.
  + `서버 힌트 기능`: 서버가 클라이언트에게 리퀘스트 해야 할 리소스를 제안할 수 있다.
- 하지만 SPDY는 복수의 도메인으로 리소스를 사용하는 경우에는 효과가 한정적이다. 
- SPDY는 HTTP의 병목 현상을 해결하는 좋은 기술 이지만, 대부분의 웹 사이트의 문제는 HTTP 병목 현상 때문만은 아니다.         

### WebSocket
- `WebSocket`은 웹 브라우저와 웹 서버를 위한 양방향 통신 규격이다. 웹 서버와 클라이언트가 한 번 접속을 확립하고 나면 그 뒤의 통신은 서버와 클라이언트 어느 쪽에서도 송신할 수 있다.
- WebSocket 특징 
  + `서버 푸시 기능`:서버에서 클라이언트로 데이터를 푸시하는 기능을 제공한다.
  + `통신량의 삭감`: 접속을 하면, 접속을 유지하려 한다. 또한 헤더의 사이즈가 작기 떄문에 통신량을 줄일 수 있다. 
  + `핸드쉐이크/리퀘스트`: HTTP Upgrade 헤더 필드를 이용해서 HTTP to WebSocket으로 프로토콜을 변경한다. 

### HTTP/2.0
- HTTP/1.1은 기능이 부족하여 현재 웹에 적합한 프로토콜이라고 보기는 어렵다.
- HTTP/2.0은 사용자가 웹을 이용할 때의 `체감 속도의 개선을 목표하여 사양을 검토하고 있다.` 

### WebDAV
- WebDAV(Web-based Distributed Authoring and Versioning)는 웹 서버의 콘텐츠에 대해서 직접 파일 복사나 편집 작업 등을 할 수 있는 분산 파일 시스템으로 HTTP/1.1을 확장한 프로토콜이다. 

## 제 10장 웹 콘텐츠에서 사용하는 기술

### HTML
- HTML(HyperText Markup Language)은 웹 상에서 하이퍼텍스트를 보내기 위해서 개발된 언어이다.
- `하이퍼텍스트`는 문서에 이미지 등에 링크가 포함된 문서이다. 
- `마크업 언어`는 문서의 일부에 특별한 문자열을 붙여 문자를 수식하는 언어이다. 

### CSS
- CSS(Cascading Style Sheets)는 `스타일 시트`라고 불리며, HTML 각 요소에 표시를 줘서 브라우저에 보이는 외관을 변경할 수 있다.
- CSS는 `문서의 구조와 디자인을 분리한다`는 이념에서 만들어졌다. 

### Dynamic HTML
- 정적인 HTML 내용을 JavaScript 등의 클라이언트 사이드 스크립트를 사용해서 동적으로 변경하는 기술을 말한다. ex) 클릭하면 펼쳐지는 메뉴, 구글 맵스 

#### HTML을 조작하기 쉽게 해주는 DOM
- DOM(Document Object Model)은 HTML 문서와 XML 문서를 위한 API이다. 
- `DOM을 사용하면 HTML내의 요소를 쉽게 조작할 수 있다.` 
```javascript
<script type="text/javascript">
  var content = documnet.getElementsByTagName('P');
</script>
```

### Web Application 
- `웹 애플리케이션`은 웹 기능을 사용해서 제공되는 프로그램을 지칭한다. ex) 쇼핑 사이트, 인터넷 뱅킹, SNS 등 
- 기존 정적 콘텐츠 만으로는 부족하여 웹 애플리케이션에 의해서 생성된 콘텐츠인 동적 콘텐츠가 생겨나게 됐다. 

#### 웹 서벙와 프로그램을 연계하는 CGI 
- `CGI`(Common Gateway Interface)는 웹 서버가 클라이언트에게 받은 request를 프로그램에 전달하기 위한 구조이다. 

#### Java에서 보급된 Servlet 
- `서블릿`은 서버 상에 HTML 등의 동적 콘텐츠를 생성하기 위한 프로그램이다. 
- CGI는 리퀘스트마다 프로그램을 기동하기 때문에 대량의 액세스가 있을 때 웹 서버에 부하가 걸리게 되지만 서블릿에서는 웹 서버와 같은 프로세스에서 동작하기 때문에 비교적 부하를 적게 하여 동작시킬 수 있다. 

### 데이터 송신에 이용되는 포맷이나 언어
- 범용적으로 사용할 수 있는 마크업 언어 `XML`
  + XML(eXtensible Markup Language)는 목적에 맞게 확장 가능한 마크업 언어로, 인터넷을 통해 데이터 공유를 용이하게 하는 것을 목적으로 하고 있다. 
  + XML 구조는 태그로 나뉘어져 있고 트리 구조로 되어있기 때문에 XML 구조를 해석하고 요소를 뽑아내는 파서 기능에 의해서 데이터를 쉽게 추출할 수 있다. 
- 갱신 정보를 송신하는 RSS/Atom
  + RSS와 Atom은 뉴스나 블로그의 기사 등의 갱신 정보를 송신하기 위한 문서 포맷의 총칭으로 둘 다 XML을 사용하고 있다.
- JavaScript에서 이용하기 쉽고 가벼운 `JSON`
  + JSON(JavaScript Object Notation)은 경량 데이터 기술 언어로서 JavaScript(ECMAScript)에 있어서 오브젝트 표기법을 바탕으로 하고 있다. 
  + JSON 데이터는 단순하고 가볍게, 게다가 문자열을 JavaScript에서 간단하게 읽어올 수 있다는 점에서 당초 XML이 사용되던 Ajax에서 JSON을 널리 사용하게 되었다. 





