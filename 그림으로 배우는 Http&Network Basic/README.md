# 그림으로 배우는 Http&Network Basic
: 우에노 센 지음

- 목차
  + 1장 TCP/IP, 
  + 2장 stateless, HTTP 메서드, 지속연결, 파이프라인화
  + 

## 제 1장 웹과 네트워크의 기본에 대해 알아보자 
- 클라이언트에서 서버까지 일련의 흐름을 결정하고 있는 것은 HTTP 프로토콜이다. 
- 웹은 지식 공유를 위해 고안되었다. 
- TCP/IP
  - HTTP 등장 당시에 주로 텍스트를 전송하기 위한 프로토콜이었지만, 지금은 웹이라는 틀을 넘어서 다양하게 사용되는 프로토콜이 되었다.
  - HTTP는  TCP/IP 프로토콜에서 움직인다.
  - IP는 복잡한 네트워크 망에서 가장 효율적인 방법으로 데이터를 보내는 일을 한다
  - TCP는 데이터를 잘게 잘라 보낸다. 순서가 맞지 않거나 중간에 빠진 부분을 체크하여 다시 요청을 한다. 
  - TCP/IP는 '애플리케이션 계층', '트랜스포트 계층', '네트워크 계층', '링크 계층'으로 나뉘어져 있다. 
    + 애플리케이션 계층: 송신측 클라이언트의 애플리케이션 계층에서 어느 웹 페이지를 보고 싶다라는 HTTP 리퀘스트를 지시
    + 트랜스포트 계층: 애플리케이션 계층에서 받은 데이터를 통신하기 쉽게 조각내어(패킷) 안내 번호와 포트 번호를 붙여(IP 헤더) 네트워크 계층에 전달
    + 네트워크 계층: 수신지 MAC 주소를 추가해서 링크 계층에 전달 
  - TCP/IP가 계층화되어 있기 때문에 사양이 변경되어도 해당 계층만 바꾸면 되므로 각 계층은 자유룝게 설계할 수 있다.  
  - 상대방에게 전달하기까지 여러 가지 요소가 필요한데, 그중 IP주소와 MAC 주소가 중요한 요소이다. 
  - IP 주소는 각 노드에 부여된 주소를 가리키고 MAC 주소는 각 네트워크 카드에 할당된 고유의 주소이다. 
  - `IP통신은 MAC 주소에 의존하여 통신한다.`
- TCP
  - TCP(Transfer Control Protocol)은 트랜스포트 층에 해당하는데, 신뢰성 있는 바이트 스트림 서비스를 제공한다.
  - `TCP는 대용량의 데이터를 보내기 쉽게 작게 분해하여 상대에게 보내고, 정확하게 도착했는지 확인하는 역할을 담당하고 있다.`
  - TCP는 쓰리웨이 핸드셰이킹 방법을 통해 데이터를 확실하게 보낸다. 
- `DNS(Domain Name System)는 HTTP와 같이 응용 계층 시스템에서 도메인 이름과 IP 주소 이름 확인을 제공한다.`
- HTTP 통신
  - (클라이언트) [HTTP 담당] 웹 서버에 보낼 HTTP 메세지 작성 -> [TCP 담당] 통신하기 수비도록 HTTP 메시ㅔ지를 패킷으로 분해 -> [IP 담당] 상대가 어디에 있는지 찾아 중계해(라우터) 가면서 배송 -> ... -> [IP 담당] 상대방으로부터 패킷을 수신 -> [HTTP 담당] 웹 서버에 대한 리퀘스트 내용을 처리
- URL과 URI
  - URL은 웹 페이지를 표시하기 위해 입력하는 주소이다. 
  - URI는 리소스를 식별하기 위해 문자열 전반을 나타내는데 비해 URL은 리소스의 장소를 나타낸다. 

## 제 2장 간단한 프로토콜 HTTP
- 텍스트와 이미지 등과 같은 리소스를 필요하다고 요구하는 쪽이 클라이언트가 되고, 이러한 리소스를 제공하는 쪽이 서버가 된다. 
  + 클라이언트 측으로부터 통신이 시작된다. 서버 측은 리퀘스트를 받지 않고서는 리스폰스를 송신하는 일이 없다. 
- `HTTP는 상태를 계속 유지하지 않는 stateless 프로토콜이다.`
  + 이전에 보냈던 request나 이미 되돌려준 response에 대해서는 전혀 기억하지 않는다.
  + 많은 데이터를 매우 빠르고 확실하게 처리하는 범위성(scalability)을 확보하기 위해서 이와 같이 간단하게 설계되어 있다.   
  + 서버의 CPU나 메모리 같은 리소스의 소비를 억제할 수 있다. 
- 웹이 진화함에 따라, 로그인 상태를 유지할 필요성이 대두되면서, `쿠키`라는 기술을 도입하여 상태를 계속 유지할 수 있게 되었다.
  + 쿠키는 리퀘스트와 리스폰스에 쿠키 정보를 추가해서 클라이언트의 상태를 파악하기 위한 시스템이다. 
- `HTTP/1.1은 상태를 유지하지 않는 프로토콜이다.` 
- HTTP 메서드 
  + `GET`: 리소스 획득 
  + `POST`: 엔티티 전송
  + `PUT`: 파일 전송
    - HTTP/1.1 PUT 자체에는 인증 기능이 없어 누구든지 파일을 업로드 가능하다는 보안 상의 문제가 있어 일반적인 웹 사이트에서는 사용되지 않는다.
    - 웹 애플리케이션 등에 의한 인증 기능과 짝을 이루는 경우나 REST와 같이 웹끼리 연계하는 설계 양식을 사용할 때 이용하는 경우도 있다. 
  + `HEAD`: 메시지 헤더 취득  
    - GET과 같은 기능이지만 메시지 바디는 돌려주지 않는다. 
  + `DELETE`: 파일 삭제
    - HTTP/1.1 DELETE 자체에는 PUT 메소드와 같이 인증 기능이 없기 때문에 일반적인 웹 사이트에서는 사용되지 않는다.
    - 웹 애플리케이션 등에 의한 인증 기능과 짝을 이루는 경우나 REST와 같이 웹끼리 연계하는 설계 양식을 사용할 때 이용하는 경우도 있다.   
  + `OPTIONS`: request URI로 지정한 리소스가 제공하고 있는 메소드를 문의 
  + TRACE: 경로 조사 
    - TRACE 메소드는 거의 사용되지 않는다. 
    - 크로스 사이트 트레이싱(XST)과 같은 공격을 일으키는 보안 상의 문제도 있기 떄문에 보통은 사용되지 않는다.
  + CONNECT: 프록시에 터널링 요구 
- `HTTP 초기 버전에서는 HTTP 통신을 한 번 할때마다 TCP에 의해 연결과 종료를 해야했다.` 
  + 초기 통신에서는 작은 사이즈의 텍스트를 보냈기 때문에 문제가 없었지만, 하나의 HTML에 여러 이미지가 있을 경우 매번 TCP 연결과 종료를 하게 되면서 통신량이 늘어나게 되었다.
- TCP 연결 문제를 해결하기 위해 어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상 TCP 연결을 계속 유지하는 `지속 연결(Persistent Connections)` 방법이 생겼다.  
  + HTTP/1.1에서는 표준 동작이지만 HTTP/1.0에서는 정식 사양이 아니다.
- 지속 연결은 여러 리퀘스트를 보낼 수 있도록 파이프라인화를 가능하게 하는데, `파이프라인화`에 의해서 이전에는 리퀘스트 송신 후에 리스폰스를 수신할 때까지 기다린 뒤에 리퀘스트를 발행해던 것을, 리스폰스를 기다리지 않고 바로 다음 리퀘스트를 보낼 수 있다.   

## 제 3장 HTTP 정보는 HTTP 메시지에 있다. 
- HTTP 메시지는 `메시지 헤더`와 `메시지 바디`로 구분되어 있고, 최초로 나타나는 `개행 문자(CR+LF)`로 메시지 헤더와 메시지 바디를 구분한다.
  ```
  [메시지 헤더]
  개행문자
  [메시지 헤더]
  ```
- 메시지 헤더 내부는 리퀘스트/상태 라인, 리퀘스트/리스폰스 헤더 필드, 일반 헤더 필드, 엔티티 헤더 필드, 그 외(쿠키 필드)로 구성되어 있다. 
- HTTP 데이터를 전송할 때 인코딩을 실시하면 전송 효율을 높일 수 있다. 
  + 대신 CPU 등의 리소스를 많이 소비한다.
- HTTP의 `콘텐츠 코딩(Content Codings)`라는 기능을 사용하면 zip과 같은 압축 파일을 첨부할 수 있다. 
- 사이즈가 큰 데이터를 분할해서 조금씩 보낼 수 있는데, 이렇게 바디를 분할하는 기능을 `청크 전송 코딩(Chunked transfer Coding)`이라 부른다. 
  + 기존에는 엔티티 바디의 전송이 완료되지 않으면 브라우저에 표시되지 않았다.
  + 청크 전송 코딩을 이용하면 데이터를 분할해서 조금씩 표시할 수 있다.
- 멀티파트
  - 멀티파트는 파트마다 헤더 필드가 포함된다.
  - 멀티파트 각각의 엔티티를 구분하기 위해 `bounday` 문자열을 사용한다. 
  - HTTP에서는 `multipart/form-data`로 하나의 메시지 바디 내부에 여러 개의 엔티티를 포함시켜 보낼 수 있다.  
    ```
    Content-Type: multipart/form-data boundary=AaB03x
    --AaB03x
    Content-DispositionL form-data; name="f1"
    visual
    --AaB03X
    Content-DispositionL form-data; name="f1.txt"
    visual
    --AaB03X--
    ```
  - HTTP에서는 `multipart/byteranges`로 response 메시지에 복수 범위의 내용을 포함시켜 보낼 수 있다. 상태 코드 `206 Partial Content`로 들어온다. 
    + 기존에는 대용량의 데이터를 다운로드 중에 커넥션이 끊어지게 되면 처음부터 다시 다운로드를 했었다.
    + 이전에 다운로드를 한 곳에서부터 다운로드를 재개할 수 있도록 `리줌(resume)`이라는 기능을 제공한다. 리줌 덕분에 엔티티 범위를 지정해서 다운로드 하는 레인지 리퀘스트를 할 수 있다. 
    ```
    HTTP/1.1 206 Partial Content
    Date: ...
    Last-Modified: ...
    Content-Type: multipart/byteranges: boundary=THIS_STRING_SEPARATES
    --THIS_STRING_SEPARATES
    Content-Type: application/pdf
    Content-Range: bytes 500-900/5000
    --THIS_STRING_SEPARATES
    Content-Type: application/pdf
    Content-Range: bytes 4000-4900/5000
    --THIS_STRING_SEPARATES--
    ```  
- 언어에 따라 알맞은 웹 페이지를 표시하는 구조를 콘텐츠 네고시에이션(Content Negotiation)이라 한다. 언어와 문자 세트, 인코딩 방식 등을 기준으로 리소스를 제공한다.
  + 서버 구동형 네고시에이션: 서버 측에서 콘텐츠 네고시에이션을 수행한다. 주로 리퀘스트의 헤더 정보를 참고해서 자동적으로 처리한다. 
  + 에이전트 구동형 네고시에이션 : 클라이언트 측에서 수동으로 언어를 선택한다.
  + 트랜스페이런트(투명한) 네고시에이션 : 서버와 클라이언트 각각 네고시에이션을 수행한다.

## 제 4장 결과를 전달하는 HTTP 상태 코드
- 서버는 클라이언트가 보낸 리퀘스트 결과를 `상태 코드`로 알려준다. 
- `1xx` `Informational` 처리중
- `2xx` `Success` 정상 처리 했음
  + 200 OK: 정상 처리
  + 204 No Content: 처리는 성공했지만 돌려줄 리소스가 없음
  + 206 Partial Content: Range Request 처리
- `3xx` `Redirection` 추가 동작 필요 
  + 301 Moved Permanently: 요청한 URI가 다른 URI로 변경되었음을 알리며, 변경된 URI로 redirect 처리
  + 302 Found: 요청한 URI가 다른 URI로 임시 변경되었음을 알리며, 변경된 URI로 redirect 처리
  + 303 See Other: POST 메소드로 처리 한 결과를 별도의 URI의 GET 메소드로 redirecet 처리
  + 304 Not Modified: 리소스에 대한 액세스는 허락하지만, 조건이 충족되지 않음을 의미. Response Body에 어떤 데이터도 포함되어 있지 않는다
  + 307 Temporary Redirect:    
- `4xx` `Cilent Error` 
  + 400 Bad Request: request 구문이 잘못되었음을 의미 
  + 401 Unauthorized: HTTP 인증 정보가 필요 or 인증 실패
  + 403 Forbidden: 액세스 권한이 없어서 거부 되었음을 의미 
  + 404 Not FOund: 서버에 없는 리소스를 의미
- `5xx` `Server Error` 
  + 500 Internal Server Error: 서버에서 request를 처리하는 도중 에러가 발생
  + 503 Service Unavaliable: 일시적으로 서버가 과부하 상태이거나 점검중이기 때문에 request를 처리할 수 없음을 의미

## 제 5장 HTTP와 연계하는 웹 서버 
- HTTP/1.1에서는 하나의 HTTP 서버에 `가상 호스트(Virtual Host)`를 둬서 여러 개의 웹 사이트를 실행할 수 있다. 
- 같은 IP 주소에서 다른 호스트명과 도메인 명을 가진 여러 개의 웹 사이트가 실행되고 있는 가상 호스트의 시스템이 있기 때문에, HTTP request를 보내는 경우에는 호스트명과 도메인 명을 완전하게 포함한 URI를 지정하거나, 반드시 Host 헤더 필드에서 지정해야 한다. 
- `프록시(Proxy)`
  - `프록시 서버는 서버와 클라이언트 중간에 위치하여 클라이언트의 리퀘스트를 서버에 전송하고, 서버로부터 받은 리스폰스를 클라이언트에게 전달한다.`
  - `캐시`를 사용해 네트워크 대역을 효율적으로 사용하거나 특정 웹 사이트에 대한 `액세스 제한, 액세스 로그를 획득`하려는 목적으로 사용된다. 
  + `캐싱 프록시`: `프록시 서버 상에 리소스 캐시(리소스 사본)를 보존하여 오리진 서버로부터 리소스를 획득하는 것이 아니라 캐시를 response로 돌려준다.` 캐시를 가지고 있더라도 클라이언트의 요구나 캐시의 유효 기간 등에 의해서 오리진 서버에 리소스의 유효성을 확인하거나 새로운 리소스를 다시 획득하러 가게 되는 경우가 있다. 
  + 투명 프록시: request와 response를 중계 할 때 메시지를 변경하지 않는 타입이다. <-> 비투과 프록시
- `게이트웨이(Gateway)`
  + 다른 서버를 중계하는 서버로, 클라이언트로부터 수신한 리퀘스트를 리소스를 보유한 서버인 것처럼 수신한다. HTTP 프로토콜 이외의 서버와 통신 서비스를 제공한다. 클라이언트와 게이트웨이 사이를 암호화하여 통신의 안전성을 높여준다. 
- `터널(Tunnel)` 
  + 터널을 사용하면 클라이언트는 서버와 SSL 같은 암호화 방법으로 안전하게 통신할 수 있다. 
- `캐시는 클라이언트가 사용하고 있는 부라우저에서도 캐시를 가질 수 있다. 클라이언트가 보존하는 캐시를 인터넷 임시 파일이라 부른다.` 

## 제 6장 HTTP 헤더 

#### HTTP/1.1 일반 헤더 필드 

###### Cache-Control: 캐싱 동작 지정 
`Cache-Control: private, max-age=0, no-cache`
- Cache-Control request
  + `Cache-Control: no-cache`: 캐시가 있더라도 항상 오리진 리소스를 요청한다.
  + `Cache-Control: no-store`: 기밀 정보가 포함되어 있으므로 캐시의 일부분을 보존해서는 안된다.
  + `Cache-Control: max-age=604800(초)`: 최대 Age 값
  + `Cache-Control: max-state=3600`: 캐시의 유효기간이 만료된지 3600초 이내라면, 리소스 캐시를 받아들이겠다는 의미이다. 
  + `Cache-Control: min-fresh=60`: 캐시가 앞으로 60초 이상 유효하다면, 리소스 캐시를 받아들이겠다는 의미이다. 
  + `Cache-Control: no-transform`: response body의 미디어 타입을 변경하지 않도록 지정한다. 캐시 서버 등에 의해서 이미지가 압축되는 것을 방지하기 위해
  + `Cache-Control: only-if-cached`: 캐시 서버에 캐시가 있는 경우만 반환하고, 그렇지 않으면 504 Gateway Timeout을 반환한다. 
- Cache-Control response
  + `Cache-Control: public`: 어떤 유저에게도 캐시를 돌려줘도 좋다
  + `Cache-Control: private`: 특정 유저만 캐시로 반환하고, 다른 유저는 캐시를 반환하지 않도록한다. 
  + `Cache-Control: no-cache`: 캐시 서버는 리소스를 저장할 수 없다.  
  + `Cache-Control: no-store`: 기밀 정보가 포함되어 있으므로 캐시의 일부분을 보존해서는 안된다.
  + `Cache-Control: no-transform`: response body의 미디어 타입을 변경하지 않도록 지정한다. 캐시 서버 등에 의해서 이미지가 압축되는 것을 방지하기 위해
  + `Cache-Control: must-revalidate`: 캐시가  현재도 유효한지 아닌지 오리진 서버에 리소스의 재확인을 요구한다. 
  + `Cache-Control: proxy-revalidate`: 중간 캐시 서버에서 캐시를 반환할 때 캐시 유효성의 재확인을 요구한다. 
  + `Cache-Control: max-age=604800(초)`: 최대 Age 값
  + `Cache-Control: s-maxage=604800(초)`: 공유 캐시 서버의 최대 Age 값 

###### Connection: Hop-by-hop 헤더, 커넥션 관리 
- 프록시에 더 이상 전송하지 않는 헤더 필드(hop-by-hop 헤더)를 지정
- 지속적 접속관리 
  + `Connection: Close`: 지속적 접속을 서버 측에서 명시적으로 접속을 끊고 싶을 경우에 사용한다.
  + `Connection: Keep-Alive`: HTTP/1.1 이전 버전은 지속적 접속이 디폴트가 아니기 때문에, 지속적 접속을 하고 싶은 경우 지정해줘야 한다. 

###### Date: 메시지 생성 날짜 
- `Date: Tue, 03 Jul 2012 04:40:68 GMT`

###### Pragma: 메시지 제어 
- HTTP/1.0 버전과 호환성을 위해서 정의되어 있는 헤더 필드이다.
- 중간 서버의 HTTP 버전에 HTTP/1.0이 있을 수 있으므로 캐시 동작 지정을 아래와 같이 양쪽으로 보내는 경우도 있다. 
  ```
  Cache-Control: no-cache
  Pragma: no=cache 
  ```

###### Trailer: 메시지의 끝에 있는 헤더의 알람 
```
...
Transfer-Encoding: chunked
Trailer: Expires 
...(메시지 바디)...
0
Expires: Tue, 28 Sep 2004 23:5959 GMT
```
- 메시지 바디의 뒤에 기술되어 있는 헤더 필드를 미리 전달 할 수 있습니다. 반드시 `청크 전송 인코딩`을 사용하고 있는 경우에 사용 가능하다.

###### Transfer-Encoding: 메시지 바디의 전송 코딩 형식 지정 
`Transfer-Encoding: chunked`
- 메시지 바디의 전송 코딩 형식을 지정하는 경우에 사용한다. HTTP/1.1에는 `chuncked`만 지정이 가능하다.

###### Upgrade: 다른 프로토콜에 업그레이드 
- HTTP 및 다른 프로토콜의 새로운 버전이 통신에 사용되는 경우에 사용합니다.

###### Via: 프록시 서버에 관한 정보 
- 프록시 혹은 게이트웨이가 자신의 `경로`를 알리기 위해 Via 헤더에 추가한다. 
- 메시지의 추적과 리퀘스트 루프의 회피 등에 사용된다. 

###### Warning: 에러 통지 
- 리스폰스에 관한 추가 정보를 전달합니다. 기본적으로 캐시에 관한 문제의 경고 를 유저에 전달한다.

#### HTTP/1.1 리퀘스트 헤더 필드 

###### Accept: 유저 에이전트가 처리 가능한 미디어 타입
`Accept: text/html, application/xhtml+xml,application/xml;q=0.9,*/*,q=0.8`
- 유저 에이전트에 처리할 수 있는 미디어 타입과 미디어 타입의 상대적인 우선 순위를 전달하기 위해서 사용된다. 
- 표시하는 미디어 타입에 `우선 순위`를 붙이고 싶을 경우에는 세미콜론 ";"으로 구분하고 "q="로 표시할 `품질 지수`를 더한다. 품질 계수의 디폴트 값은 1.0이다. 

###### Accept-Charset: 문자셋 우선 순위 
`Accept-Charset: iso-8859-5, unicode-1-1:q+0.8`
- 유저 에이전트에서 처리할 수 있는 문자셋으로, 문자셋의 상대적인 우선 순위를 전달하기 위해 사용된다. 
- 서버 구동형 네고시에이션에서 이용

###### Accept-Encoding: 콘텐츠 인코딩 우선 순위 
`Accept-Encoding: gzip, deflate`
- 유저 에이전트가 처리할 수 있는 콘텐츠 코딩과 콘텐츠 코딩의 상대적인 우선 순위를 전달하기 위해 사용된다. 

###### Accept-Language: 언어 우선 순위 
`Accept-Language: ko-kr, en-us;q=0.7,en;q=0.3`
- 유저 에이전트가 처리할 수 있는 자연어의 세트(한국어+영어)와 자연어 세트의 상대적인 우선 순위를 전달하기 위해 사용 

###### Authorization: 웹 인증을 위한 정보 
`Authorization: Basic dWVub3NlbjpwYXNzd29yZA==`
- 유저 에이전트의 인증 정보를 전달하기 위해 사용

###### Expect: 서버에 대한 특정 동작의 기대 
`Expect: 100-continue`
- 클라이언트가 서버에 특정 동작 요구를 전달한다.

###### From: 유저의 메일 주소 
`From: info@hackr.jp`
- 유저 에이전트를 사용하고 있는 유저의 메일 주소를 전달한다. (경우에 따라 User-Agent 헤더 필드도 사용함)

###### Host: 요구된 리소스의 호스트 
`Host: www.hackr.jp`
-  Host 헤더 필드는 리퀘스트한 리소스의 인터넷 호스트와 포트번호를 전달한다. Host 헤더 필드는 HTTP/1.1에서 유일한 필수 헤더 필드이다. 서버에 Host 명이 없는 경우 비워서 전송한다.

###### If-Match: 엔티티 태그의 비교 
`If-Match: "123456"`
- 요청한 리소스의 엔티티태그가 "123456"인 경우에만 리퀘스트를 받는다. 아닌 경우에는 412 Precondition Failed를 전달한다.

###### If-Modified-Since: 리소스의 갱신 시간 비교 
`If-Modified-Since : Thu, 15 Apr 2004 00:00:00 GMT`
- 리소스가 2004년 4월 15일 이후에 갱신되었다면 리퀘스트를 받는다. 아닌 경우에는 304 Not Modified를 전달한다. 

###### If-None-Match: 엔티티 태그의 비교(If-Match의 반대)
- 지정된 값이 일치하지 않으면 리퀘스트를 받는다. 

###### If-Range: 리소스가 생신되지 않은 경우에 엔티티의 바이트 범위의 요구를 송신 
`If-Range : "123456" Range: byte=5001-10000`
- 리소스의 엔티티 태그가 "123456"이면 서버는 요청한 5000 바이트만 전송한다. 

###### If-Unmodified-Since: 리소스의 갱신 시간 비교(If-Modified-Since의 반대)
- 지정된 리소스가 필드 값에 지정된 날짜 이후에 갱신되어 있지 않는 경우에만 리퀘스트를 받는다.

###### Max-Forwards: 최대 전송 홉수 
`Max-forwards: 10`
- TRACE 혹은 OPTIONS 메소드에 의한 리퀘스트를 할 때에 전송해도 좋은 서버 수의 최대치를 10진수 정수로 지정한다. 
- 서버는 다음 서버에 리퀘스트를 전송할 때는 값에서 1을 빼서 다시 세트한다. Max-Forwards 값이 0이로 바뀐 서버는 response를 반환한다.
- 필드 값이 0이 되었던 서버가 response를 하기 때문에 그 서버까지의 상황을 알 수 있다. 

###### Proxy-Authorization: 프록시 서버의 클라이언트 인증을 위한 정보 
`Proxy-Authorization : Basic dGlwOjkpNLAGfFY5`
- 클라이언트와 서버의 HTTP 엑세스 인증과 비슷한데 다른 점은 클라이언트와 프록시 사이에 인증이 이루어진다.

###### Range: 엔티티 바이트 범위 요구 
`Range : byte=5001-10000`
- 리소스의 일부분만 취득하는 Range request를 할 때 지정범위이다.

###### Referer: 리퀘스트중의 URI를 취득하는 곳
`Referer : http://www.hackr.jp/index.html`
- 현재 보내고 있는 리퀘스트를 어느 웹 페이지에서부터 발행되었는지를 전달한다. 보안상 바람직하지 않다고 판단되는 경우는 보내지 않아도 된다.

###### TE: 전송 인코딩의 우선 순위
`TE: gzip, deflate;q=0.5`
- response로 받을 수 있는 전송 코딩의 형식과 상대적인 우선 순위를 전달한다. 

###### User-Agent: HTTP 클라이언트의 정보 
`User-Agent:Mozila/5.0(Windows NT 6.1) AppleWebKit/535.19 ...`
- 리퀘스트를 생성한 브라우저와 유저 에이전트의 이름 등을 전달하기 위한 필드이다.

