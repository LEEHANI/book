# 그림으로 배우는 Http&Network Basic
: 우에노 센 지음

- 목차
  + 1장 TCP/IP, 
  + 2장 stateless, HTTP 메서드, 지속연결, 파이프라인화
  + 

## 제 1장 웹과 네트워크의 기본에 대해 알아보자 
- 클라이언트에서 서버까지 일련의 흐름을 결정하고 있는 것은 HTTP 프로토콜이다. 
- 웹은 지식 공유를 위해 고안되었다. 
- TCP/IP
  - HTTP 등장 당시에 주로 텍스트를 전송하기 위한 프로토콜이었지만, 지금은 웹이라는 틀을 넘어서 다양하게 사용되는 프로토콜이 되었다.
  - HTTP는  TCP/IP 프로토콜에서 움직인다.
  - IP는 복잡한 네트워크 망에서 가장 효율적인 방법으로 데이터를 보내는 일을 한다
  - TCP는 데이터를 잘게 잘라 보낸다. 순서가 맞지 않거나 중간에 빠진 부분을 체크하여 다시 요청을 한다. 
  - TCP/IP는 '애플리케이션 계층', '트랜스포트 계층', '네트워크 계층', '링크 계층'으로 나뉘어져 있다. 
    + 애플리케이션 계층: 송신측 클라이언트의 애플리케이션 계층에서 어느 웹 페이지를 보고 싶다라는 HTTP 리퀘스트를 지시
    + 트랜스포트 계층: 애플리케이션 계층에서 받은 데이터를 통신하기 쉽게 조각내어(패킷) 안내 번호와 포트 번호를 붙여(IP 헤더) 네트워크 계층에 전달
    + 네트워크 계층: 수신지 MAC 주소를 추가해서 링크 계층에 전달 
  - TCP/IP가 계층화되어 있기 때문에 사양이 변경되어도 해당 계층만 바꾸면 되므로 각 계층은 자유룝게 설계할 수 있다.  
  - 상대방에게 전달하기까지 여러 가지 요소가 필요한데, 그중 IP주소와 MAC 주소가 중요한 요소이다. 
  - IP 주소는 각 노드에 부여된 주소를 가리키고 MAC 주소는 각 네트워크 카드에 할당된 고유의 주소이다. 
  - `IP통신은 MAC 주소에 의존하여 통신한다.`
- TCP
  - TCP(Transfer Control Protocol)은 트랜스포트 층에 해당하는데, 신뢰성 있는 바이트 스트림 서비스를 제공한다.
  - `TCP는 대용량의 데이터를 보내기 쉽게 작게 분해하여 상대에게 보내고, 정확하게 도착했는지 확인하는 역할을 담당하고 있다.`
  - TCP는 쓰리웨이 핸드셰이킹 방법을 통해 데이터를 확실하게 보낸다. 
- `DNS(Domain Name System)는 HTTP와 같이 응용 계층 시스템에서 도메인 이름과 IP 주소 이름 확인을 제공한다.`
- HTTP 통신
  - (클라이언트) [HTTP 담당] 웹 서버에 보낼 HTTP 메세지 작성 -> [TCP 담당] 통신하기 수비도록 HTTP 메시ㅔ지를 패킷으로 분해 -> [IP 담당] 상대가 어디에 있는지 찾아 중계해(라우터) 가면서 배송 -> ... -> [IP 담당] 상대방으로부터 패킷을 수신 -> [HTTP 담당] 웹 서버에 대한 리퀘스트 내용을 처리
- URL과 URI
  - URL은 웹 페이지를 표시하기 위해 입력하는 주소이다. 
  - URI는 리소스를 식별하기 위해 문자열 전반을 나타내는데 비해 URL은 리소스의 장소를 나타낸다. 

## 제 2장 간단한 프로토콜 HTTP
- 텍스트와 이미지 등과 같은 리소스를 필요하다고 요구하는 쪽이 클라이언트가 되고, 이러한 리소스를 제공하는 쪽이 서버가 된다. 
  + 클라이언트 측으로부터 통신이 시작된다. 서버 측은 리퀘스트를 받지 않고서는 리스폰스를 송신하는 일이 없다. 
- `HTTP는 상태를 계속 유지하지 않는 stateless 프로토콜이다.`
  + 이전에 보냈던 request나 이미 되돌려준 response에 대해서는 전혀 기억하지 않는다.
  + 많은 데이터를 매우 빠르고 확실하게 처리하는 범위성(scalability)을 확보하기 위해서 이와 같이 간단하게 설계되어 있다.   
  + 서버의 CPU나 메모리 같은 리소스의 소비를 억제할 수 있다. 
- 웹이 진화함에 따라, 로그인 상태를 유지할 필요성이 대두되면서, `쿠키`라는 기술을 도입하여 상태를 계속 유지할 수 있게 되었다.
  + 쿠키는 리퀘스트와 리스폰스에 쿠키 정보를 추가해서 클라이언트의 상태를 파악하기 위한 시스템이다. 
- `HTTP/1.1은 상태를 유지하지 않는 프로토콜이다.` 
- HTTP 메서드 
  + `GET`: 리소스 획득 
  + `POST`: 엔티티 전송
  + `PUT`: 파일 전송
    - HTTP/1.1 PUT 자체에는 인증 기능이 없어 누구든지 파일을 업로드 가능하다는 보안 상의 문제가 있어 일반적인 웹 사이트에서는 사용되지 않는다.
    - 웹 애플리케이션 등에 의한 인증 기능과 짝을 이루는 경우나 REST와 같이 웹끼리 연계하는 설계 양식을 사용할 때 이용하는 경우도 있다. 
  + `HEAD`: 메시지 헤더 취득  
    - GET과 같은 기능이지만 메시지 바디는 돌려주지 않는다. 
  + `DELETE`: 파일 삭제
    - HTTP/1.1 DELETE 자체에는 PUT 메소드와 같이 인증 기능이 없기 때문에 일반적인 웹 사이트에서는 사용되지 않는다.
    - 웹 애플리케이션 등에 의한 인증 기능과 짝을 이루는 경우나 REST와 같이 웹끼리 연계하는 설계 양식을 사용할 때 이용하는 경우도 있다.   
  + `OPTIONS`: request URI로 지정한 리소스가 제공하고 있는 메소드를 문의 
  + TRACE: 경로 조사 
    - TRACE 메소드는 거의 사용되지 않는다. 
    - 크로스 사이트 트레이싱(XST)과 같은 공격을 일으키는 보안 상의 문제도 있기 떄문에 보통은 사용되지 않는다.
  + CONNECT: 프록시에 터널링 요구 
- `HTTP 초기 버전에서는 HTTP 통신을 한 번 할때마다 TCP에 의해 연결과 종료를 해야했다.` 
  + 초기 통신에서는 작은 사이즈의 텍스트를 보냈기 때문에 문제가 없었지만, 하나의 HTML에 여러 이미지가 있을 경우 매번 TCP 연결과 종료를 하게 되면서 통신량이 늘어나게 되었다.
- TCP 연결 문제를 해결하기 위해 어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상 TCP 연결을 계속 유지하는 `지속 연결(Persistent Connections)` 방법이 생겼다.  
  + HTTP/1.1에서는 표준 동작이지만 HTTP/1.0에서는 정식 사양이 아니다.
- 지속 연결은 여러 리퀘스트를 보낼 수 있도록 파이프라인화를 가능하게 하는데, `파이프라인화`에 의해서 이전에는 리퀘스트 송신 후에 리스폰스를 수신할 때까지 기다린 뒤에 리퀘스트를 발행해던 것을, 리스폰스를 기다리지 않고 바로 다음 리퀘스트를 보낼 수 있다.   

## 제 3장 HTTP 정보는 HTTP 메시지에 있다. 
- HTTP 메시지는 `메시지 헤더`와 `메시지 바디`로 구분되어 있고, 최초로 나타나는 `개행 문자(CR+LF)`로 메시지 헤더와 메시지 바디를 구분한다.
```
[메시지 헤더]
개행문자
[메시지 헤더]
```
- 메시지 헤더 내부는 리퀘스트/상태 라인, 리퀘스트/리스폰스 헤더 필드, 일반 헤더 필드, 엔티티 헤더 필드, 그 외(쿠키 필드)로 구성되어 있다. 
- HTTP 데이터를 전송할 때 인코딩을 실시하면 전송 효율을 높일 수 있다. 
  + 대신 CPU 등의 리소스를 많이 소비한다.
- HTTP의 `콘텐츠 코딩(Content Codings)`라는 기능을 사용하면 zip과 같은 압축 파일을 첨부할 수 있다. 
- 사이즈가 큰 데이터를 분할해서 조금씩 보낼 수 있는데, 이렇게 바디를 분할하는 기능을 `청크 전송 코딩(Chunked transfer Coding)`이라 부른다. 
  + 기존에는 엔티티 바디의 전송이 완료되지 않으면 브라우저에 표시되지 않았다.
  + 청크 전송 코딩을 이용하면 데이터를 분할해서 조금씩 표시할 수 있다.
- 멀티파트
  - 멀티파트는 파트마다 헤더 필드가 포함된다.
  - 멀티파트 각각의 엔티티를 구분하기 위해 `bounday` 문자열을 사용한다. 
  - HTTP에서는 `multipart/form-data`로 하나의 메시지 바디 내부에 여러 개의 엔티티를 포함시켜 보낼 수 있다.  
    ```
    Content-Type: multipart/form-data boundary=AaB03x
    --AaB03x
    Content-DispositionL form-data; name="f1"
    visual
    --AaB03X
    Content-DispositionL form-data; name="f1.txt"
    visual
    --AaB03X--
    ```
  - HTTP에서는 `multipart/byteranges`로 response 메시지에 복수 범위의 내용을 포함시켜 보낼 수 있다. 상태 코드 `206 Partial Content`로 들어온다. 
    + 기존에는 대용량의 데이터를 다운로드 중에 커넥션이 끊어지게 되면 처음부터 다시 다운로드를 했었다.
    + 이전에 다운로드를 한 곳에서부터 다운로드를 재개할 수 있도록 `리줌(resume)`이라는 기능을 제공한다. 리줌 덕분에 엔티티 범위를 지정해서 다운로드 하는 레인지 리퀘스트를 할 수 있다. 
    ```
    HTTP/1.1 206 Partial Content
    Date: ...
    Last-Modified: ...
    Content-Type: multipart/byteranges: boundary=THIS_STRING_SEPARATES
    --THIS_STRING_SEPARATES
    Content-Type: application/pdf
    Content-Range: bytes 500-900/5000
    --THIS_STRING_SEPARATES
    Content-Type: application/pdf
    Content-Range: bytes 4000-4900/5000
    --THIS_STRING_SEPARATES--
    ```  
- 언어에 따라 알맞은 웹 페이지를 표시하는 구조를 콘텐츠 네고시에이션(Content Negotiation)이라 한다. 언어와 문자 세트, 인코딩 방식 등을 기준으로 리소스를 제공한다.
  + 서버 구동형 네고시에이션: 서버 측에서 콘텐츠 네고시에이션을 수행한다. 주로 리퀘스트의 헤더 정보를 참고해서 자동적으로 처리한다. 
  + 에이전트 구동형 네고시에이션 : 클라이언트 측에서 수동으로 언어를 선택한다.
  + 트랜스페이런트(투명한) 네고시에이션 : 서버와 클라이언트 각각 네고시에이션을 수행한다.



