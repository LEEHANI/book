만화로 배우는 리눅스 시스템 관리    
===
:명령어 & 셸 스크립트 입문   

- [ssh](#1-다른-컴퓨터를-리모트로-조작하고-싶어ssh)
- [sudo](#2-임시로-관리자-권한을-얻고-싶어sudo)
- [grep](#3-다양한-문자열을-한-번에-검색하고-싶어grep)
- [vim](#4-터미널에서도-대화형으로-파일을-편집하고-싶어vim)
- [yank](#5-vim에서도-복사-붙이기-되돌리기를-하고-싶어yank)
- [가상터미널(tmux)](#6-갑작스러운-네트워크-끊김에서-복귀하고-싶어가상-터미널)
- [화면분할(tmux)](#7-다른-화면도-보면서-작업하고-싶어화면-분할)
- [명령어 이력(~/.bash_history)](#8-최근-실행한-명령어를-호출하고-싶어명령어-이력)
- [명령어 이력 검색](#9-오래전에-실행한-명령어를-호출하고-싶어명령어-이력-검색)
- [scp](#10-네트워크-건너서-파일을-복사하고-싶어scp)
- [top(load average, %cpu, TIME+)](#11-시스템-과부하를-파악하고-싶어top)
- [top(스왑))](#12-시스템-메모리-부족을-파악하고-싶어top-표시-전환)
- [| 파이프라인](#13-로그-파일에서-필요한-줄만-뽑고-싶어파이프라인)
- [shell script](#14-작업-절차를-자동화하고-싶어셸-스크립트)
- [shell variable](#15-같은-문자열을-스크립트에서-재사용하고-싶어셸-변수)




## 1. 다른 컴퓨터를 리모트로 조작하고 싶어(SSH)
- SSH는 secure Shell의 약어   
- 다른 PC에 네트워크 경유로 로그인해서 자기 PC 처럼 조작 가능   
- ```ex) ssh user@127.0.0.1```  
<br/>

## 2. 임시로 관리자 권한을 얻고 싶어(sudo)  

- sudo 명령어로 임시 관리자 권한 획득 가능    
- ```ex) sudo launchctl load /Library/LaunchDaemons/org.jenkins-ci.plist ```   
<br/>  

## 3. 다양한 문자열을 한 번에 검색하고 싶어(grep)  

- grep: global regular expression print  
- 파일 내용에 문자열이 포함되어 있는지 검색  
- 정규 표현식과 같이 사용하면 좋다    
```   
ex) grep -r "may" /var/share    
-r 옵션은 서브 폴더까지 검색  
-E 옵션은 정규 표현식으로 검색    
-i 옵션은 대소문자를 무시하고 검색  
ex) grap "orange" /var/log/apache2/access.log #-r 옵션이 없으면 파일 안에서 지정한 내용을 포함한 줄을 찾을 수 있다. 
```   
<br/>  

## 4. 터미널에서도 대화형으로 파일을 편집하고 싶어(vim)
- 명령줄 텍스트 에디터의 vim은 vi의 강화판  
- vim의 기본이 되는 vi는 일반적인 PC가 아직 없던 시대에 텐키나 커서 키, 마우스 등이 없던 환경을 위해 만들어짐. 그래서 하나의 키가 여러 역할을 하도록 설계되어 있음 
  + 노멀 모드: 홈 화면. 다른 모드에서 ESC를 누르면 노멀 모드로 변경됨. :wq 하면 저장 후 종료  
  + 끼워넣기 모드: 홈 화면에서 i 누르면 됨.  
  + 검색 모드: 홈 화면에서 / 누른 후 찾고 싶은 문자열 입력. n 누르면 다음, shift는 이전 문자열로 이동. /\v 로 정규 표현식 가능    
``` 
ex) /name
    /\v(I|i|L)
``` 
<br/>  

## 5. vim에서도 복사 & 붙이기 & 되돌리기를 하고 싶어(yank)  
GUI 애플리케이션과 콘솔 애플리케이션은 전혀 다른 규칙으로 동작하기 때문에 Ctrl+C,V가 동작하지 않는다.    
- 복사: ```V``` 키 누르고 복사하고 싶은 영역까지 커서 옮긴 다음에 ```Y``` 누르기   
- 붙여넣기: ```Shift+P```   
- 되돌리기: 노멀 모드에서 ```U``` 키   
- 되돌리기의 되살리기: ```Ctrl+R```   
<br/>  

## 6. 갑작스러운 네트워크 끊김에서 복귀하고 싶어(가상 터미널)  
- 가상 단말은 내 콘솔과 다른 컴퓨터의 콘솔이 있을 때, 그 사이를 중계하는 역할을 한다.   
- SSH 접속이 갑작스럽게 끊겨도 가상 단말은 계속 동작 상태이기 때문에 다시 접속하면 하던 작업을 이어서 할 수 있다.  
- SSH로 서버 접속 후 tmux 명령어를 사용하면 가상 단말 실행됨    
- 갑작스럽게 접속 끊기면 SSH 접속 후 tmux attach 입력  
- tmux에 대한 명령어를 입력하고 싶으면 Ctrl+B를 먼저 눌러야한다.
  + Ctrl+B -> D detach
  + Ctrl+B -> C create
  + Ctrl+B -> P previous
  + Ctrl+B -> N next
- 그외에 scree, byobu가 있다. 
<br/>  

## 7. 다른 화면도 보면서 작업하고 싶어(화면 분할)  
tmux 단말에서 화면 분할   
- 가로 분할: ```Ctrl+B, "```  
- 세로 분할: ```Ctrl+B, %```  
- 포커스 이동: ```Ctrl+B```, 상하좌우 방향키  
- 분할 해제: ```exit```  
- 스크롤: ```Ctrl+B, [ ]```  
<br/>  

## 8. 최근 실행한 명령어를 호출하고 싶어(명령어 이력)    
- 사용자가 입력한 명령어 이력: ```vim ~/.bash_history```
- 명령어 이력 부르기: 위쪽 방향키    
- 후방(이전) 검색 ```Ctrl + R ```  
- 전방(이후) 검색 ```Ctrl + S ```  
- 전방 검색을 하려면 ```~/.bashrc``` 파일에 맨 밑에 ```stty stop undef```설정 추가하고 ```source ~/.bashrc``` 명령어로 적용 시켜야 쓸수있음  
<br/>

## 9. 오래전에 실행한 명령어를 호출하고 싶어(명령어 이력 검색)  
- 재실행한 명령어는 다시 새로운 이력으로 재기록 되지만, 너무 오래 재실행하지 않으면 오래된 것부터 명령어 지움
- 이력 개수 늘리기 ```vim ~/.bashrc``` 열어서 ```Shift+G```로 파일 맨 끝으로 이동한 다음, ```export HISTSIZE=10000```, ```export HISTFILESIZE=10000``` 추가(대소문자 구분)하고 ```:wq```로 저장 후 bash 재실행 
- 터미널 생성마다 각자의 명령어 이력 복사본을 가지고 있으므로 A 터미널에서 입력한 명령어를 B 터미널은 모른다. 즉, 동기화가 되어있지 않음. 그러므로 다음 설정을 추가해야함.  
 
 ```vim _/.bashrc```
```  
function share_history {
    history -a
    history -c
    history -r
}
PROMPT_COMMAND='share_history'
shopt -u histappend
```  
<br/>

## 10. 네트워크 건너서 파일을 복사하고 싶어(scp)  
scp(Secure Copy)는 네트워크를 통해서 파일을 복사하는 명령어  
- scp가 SSH를 호출하고, SSH 통신 경로를 통해 파일을 전송한다.
- 기본 형식 ```scp [-r, 하위폴더까지] [복사할 파일] [로그인할사용자@접속할 컴퓨터 IP]```  
- 내 컴퓨터 test.txt 파일 -> 다른 컴퓨터 저장 경로 ``` scp ./test.txt may@192.168.1.0:/tmp/```  
- 다른 컴퓨터 test.txt 파일 -> 내 컴퓨터  저장 경로 ``` scp may@192.168.1.0:/tmp/test.txt ~/```  
<br/>

## 11. 시스템 과부하를 파악하고 싶어(top)  
- load average
 + load average는 CPU가 1분당 평균으로 몇개의 일이 쌓이는지 나타내는 값이다
 + 작업량이 적으면 0.1이나 0.2가 되는데, CPU가 놀고있다는 뜻이다. 
 + 멀티코어 CPU는 코어 숫자만큼 한 번에 일할 수 있다(코드쿼어는 4개)
- %cpu/ TIME+ 
 + 과부하의 원인을 찾을 땐 CPU 사용률(%cpu)과 CPU 시간(TIME+)을 보자
 + CPU 사용률이 높고 CPU 시간이 길면 과부하의 원인일 수 있다.
 + 과부하 원인은 kill명령어로 종료할 수 있다. 
<br/>

## 12. 시스템 메모리 부족을 파악하고 싶어(top 표시 전환)
- CPU 부하가 낮아도 load average가 높을 수도 있다. 과부하가 아닐 수 도 있음.
  + 그 예로 디스크 I/O가 있다. 하드 디스크에 저장한 파일을 찾거나 내용을 읽거나 파일을 저장할 때이다.
- 스왑
  + CPU는 보통 작업 장소로 메인 메모리를 사용하지만, 메모리 여유 공간이 부족하면 새로운 작업을 못한다.
  + 여유 공간이 부족하면 OS는 메모리에 있는 최근에 사용하지 않은 데이터를 정리해서 하드 디스크에 옮겨 빈 공간을 만드는 데 이걸 ```스왑아웃```이라 한다.
  + 반대로 스왑아웃한 데이터가 필요해지면 하드 디스크에서 메모리로 데이터를 옮기는데 이걸 ```스왑인```이라고 한다.
  + 스왑은 OS가 알아서 관리하니까 각각의 프로그램 메모리 상태를 관리 안해도 되지만, 계속 스왑이 발생하면 메모리가 부족해져 load average가 증가한다. 
  + 빈 메모리가 부족하면 -> 스왑(디스크 I/O)이 자주 발생 -> CPU 처리가 쌓임 -> load average가 높아져서 시스템 반응이 나빠짐 
- %MEM이 프로세스가 소비하는 메모리량. 
- 프로그램은 필요할 때만 프로세스를 실행해서 처리가 끝나면 종료하는 것(grep, ssh, vim)과 컴퓨터를 사용하는 동안 계속 프로세스를 실행시켜야 하는(apache, sshd) 상주형 프로세스(서비스)가 있다.
- 하드 디스크가 가득 차게되면 OS의 동작이 이상해질 수 있으니 OS가 멈추지 않도록 리눅스는 OS가 적당히 프로세스를 골라서 강제 종료시킨다. 이를 ```OOM Killer(Out of Memory Killer)```라고 부른다 
<br/>

## 13. 로그 파일에서 필요한 줄만 뽑고 싶어(파이프라인)  
- ```|```를 쓰면 ```a | b``` a 명령어 실행 결과를 b 명령어로 넘길 수 있다. 
- ```grep "/retro" access.log.1 | grep -v "/live" | less```와 같이 ```|```를 이용하면 원하는 조건으로 범위를 더 좁혀서 출력할 수 있다.
- 파이프라인을 사용하면 명령어끼리 조합해서 사용 가능
- grep은 다른 명령어 출력을 가공하는 데도 사용 가능
- zcat을 사용하면 압축된 로그 파일에서 바로 파이프라인으로 연결 가능 
- 파일 읽기 
  + 지정한 파일 내용을 읽어서 그래도 출력하는 ```cat```명령어. 비압축 텍스트 파일 
  + 압축 파일을 읽어서 출력하는 ```zcat``` 명령어 
    - ```zcat```은 .gz, .tgz용 
    - ```xzcat```은 .xz용 
    - ```uncat```은 zip용 
- 파일 내용 끝부분만 출력 ```tail```, -F 옵션을 지정하면 파일 변경을 감시해서 내용이 추가될 때마다 그 부분을 실시간으로 출력한다.
<br/>

## 14. 작업 절차를 자동화하고 싶어(셸 스크립트)
- 명령어 실행 절차를 입력하여 셸이 실행할 수 있도록 만든 각본 
1. 파일 생성 ```mkdir setup.sh```
2. 셔뱅과 명령어 입력
```
#!/bin/bash  //셔뱅(sheband), 인터프리터 지정
...
sudo apt-get -y install git vim ruby1.9.1 
cd /tmp
...
``` 
3. 실행 권한 부여 ```chmod +x setup.sh```
4. 실행 ```./setup.sh```
  - 파일 경로가 ```/bin``` or ```/usr/bin/``` 내부에 있으면, 파일명만 입력해도 실행 가능 
5. 명령어가 이상이 생겨서 그 시점에서 스크립트 실행을 중단하고 싶을 땐 ```if [$? != 0]; then exit; fi```라고 적기 
<br/>

## 15. 같은 문자열을 스크립트에서 재사용하고 싶어(셸 변수)
- vim에서 문자열 일괄 치환 방법
  + ```:%s/원문/수정문/ ```
  + ```:%s/lpg/log/ ```
- 스크립트 첫 부분에 문자열 정의하기
  + ex)```log=/var/log/apache2```
  + ```$변수명```, ```${변수명}```으로 사용 가능
  + 변수 안에 변수 ```pre=${log}/access.log```
<br/>

## 16. 작업 환경과 상태를 정해서 스크립트를 실행하고 싶어(환경 변수)
- 환경 변수를 사용하면 셸 스크립트 실행 시 값이 변하므로 환경에 맞는 처리가 가능해짐
- 환경 변수는 자기가 정의하지 않아도 ```$변수명```으로 값을 참조할 수 있는 특수한 변수 
  + ```${home}```
- 환경 변수 목록 보기 ```env```
- 명령어 치환 ```$(명령어열)``` 또는 ```'명령어열'```
  + ```$(date +%Y-%m-%d)```
  + ```today=$(date +%Y-%m-%d)```
  + 치환 명령어가 겹칠수 있기 때문에 ```$(명령어열)```을 권장 
    *```$(dirname $(dirname $path))```
<br/>

