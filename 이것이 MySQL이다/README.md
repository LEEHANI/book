# 이것이 MySQL 이다 
- 유트브 강의
https://www.youtube.com/playlist?list=PLVsNizTWUw7HhYtI-4GGmlJ5yxNdwNI_X


## CHAPTER 9 인덱스 
- 대용량 데이터에서 쿼리를 효율적으로 사용
- SELECT 튜닝 
- 장점
  + 검색 속도가 무척 빨라질 수 있다(항상 그런것은 아님)
  + 해당 쿼리의 부하가 줄어들어서, 결국 시스템 전체의 성능이 향상
  + 전체에서 몇개 없는 거 찾을 때 좋음
- 단점
  + 대략 데이터베이스 크기의 10% 정도의 추가적인 공간이 필요함
  + 페이지는 `16KB`로 크기가 고정되어 있다. 
  + 처음 인덱스 생성하는데 시간이 많이 소요될 수 있다. 
  + 데이터 변경 작업이 자주 일어날 경우 성능이 나빠진다. 
  + 전체에서 중복되는 게 많을 때 사용하면 안좋음. 그냥 full scan하자  
- 종류
  + `클러스터형 인덱스`
    * `Primay Key로 지정하면 자동으로 클러스터형 인덱스가 생성된다.`
    * ALTER TABLE문으로 기본 키를 제거해도 클러스터형 인덱스가 제거됌 
    * `영어 사전`처럼 정렬되어 있음
    * 테이블당 한 개 
    * 자동으로 정렬
    * 필수는 아님
  + `보조 인덱스`(==비클러스터형 인덱스 )
    * Unique Key를 사용하면 인덱스가 자동 생성된다. 
    * 책 뒤에 `<찾아보기>`
    * 테이블당 여러 개 
    * 넣은 순서대로 그대로임(정렬x)
- `SHOW INDEX FROM table_name`
- `B-Tree` 구조 
  + 페이지 단위로 저장
  + 인덱스를 루트 노드에 저장
  + 데이터는 리프 페이지에 저장
  + SELECT 탐색 시 효율 극대화 
  + 그러나 데이터 변경 작업 시(페이지분할) 성능 떨어짐 
    * 페이지 분할: 페이지 저장 공간이 full이면 새로운 페이지를 추가해야 하는데 이게 부담스러움 
- 클러스터형 인덱스 vs 보조 인덱스 구조 
  + 클러스터형 인덱스
    * `범위 검색`에 좋음 
    * 생성 시에는 데이터 페이지 전체가 다시 정렬된다. 그러므로 이미 대용량의 데이터가 입력된 상태라면 업무시간에 클러스터형 인덱스를 생성하는 것은 심각한 시스템 부하를 줄 수 있으므로 신중하게 생각해야 한다.
    * 인덱스 자체의 리프 페이지가 곧 데이터이다. 그러므로 인덱스 자체에 데이터가 포함되어 있다고 볼 수 있다.
    * 보조 인덱스보다 검색 속도는 더 빠르다. 하지만 데이터의 입력/수정/삭제는 더 느리다 
    * 성능은 좋지만 테이블에 한 개만 생성할 수 있다. 그러므로 어느 열에 클러스터형 인덱스를 생성하는지에 따라서 시스템의 성능이 달라질 수 있다. 
  + 보조 인덱스 
    * 생성 시에는 데이터 페이지는 그냥 둔 상태에서 별도의 페이지에 인덱스를 구성한다.
    * 보조 인덱스의 인덱스 자체의 리프페이지는 데이터가 아니라 데이터가 위치하는 주소 값이다. 클러스터형보다 검색 속도는 더 느리지만 데이터의 입력/수정/삭제는 덜 느리다.
    * 여러 개 생성할 수 있다. 하지만, 함부로 남용할 경우에는 오히려 시스템 성능을 떨어뜨리는 결과를 초래할 수 있으므로 꼭 필요한 열에만 생성하는 것이 좋다. 
    * `별도의 인덱스 페이지가 만들어지고(책 뒤의 찾아보기), 데이터 영역은 그대로이다.`
- `인덱스를 검색하기 위한 일차 조건은 WHERE절에 해당 인덱스를 생성한 열의 이름이 나와야 한다. 물론, WHERE 절에 해당 인덱스를 생성한 열 이름이 나와도 인덱스를 사용하지 않는 경우도 많다. mysql이 알아서 판단 해줌`
- `SHOW TABLE STATUS LIKE table_name` 테이블 사이즈 확인                               
- 자주 검색하는 컬럼 쌍이 있다면, 묶어서 인덱스 만들기 가능 
  + ex) name and birthyear                                                         
- 인덱스는 데이터 종류의 값이 다양할 수록 좋다.
  + 성별을 인덱스로 지정해놓으면 검샐할 때마다 페이지를 계속 왔다갔다 검색해야해서 성능 떨어짐. 차라리 full scan이 나음                      
  + 왔다 갔다 하는 이유는 데이터 페이지는 정렬되어 있지 않은 상태 그대로 저장되어있기 때문에, 보조 인덱스페이지와 데이터 페이지 사이를 왔다갔다 해야함.                                         
- 인덱스를 지울 때는 보조 인덱스를 먼저 제가하는 게 효율적이다. 클러스터 인덱스를 먼저 지우면 재배치 시간이 필요함. 
- 주의해야할 점
  + WHERE 절에 연산이 들어가면 index가 적용 안됌 
    * SELECT * FROM emp_c WHERE emp_no*1 = 10000 (X)
    * SELECT * FROM emp_c WHERE emp_no = 10000/2 (O)
- 인덱스를 만들 때는 `카디널리티(cardinality)`가 높아야 한다. 즉, 데이터 중복성이 적어야한다.      
  + 차라리 안쓰는게 낫다 
  + `IGNORE INDEX (idx_gender)`
- 결론: `인덱스를 생성해야 하는 경우와 그렇지 않은 경우`
 + 인덱스는 열 단위에 생성된다.
 + WHERE절에서 사용되는 열에 인덱스를 만들어야 한다. 
 + WHERE절에 사용되더라도 자주 사용해야 가치가 있다. 
 + 데이터의 중복도가 높은 열은 인덱스를 만들어도 별 효과가 없다
 + 외래 키를 지정한 열에는 자동으로 외래 키 인덱스가 생성된다 
 + JOIN에 자주 사용되는 열에는 인덱스를 생성해 주는 것이 좋다
 + INSERT/UPDATE/DELETE가 얼마나 자주 일어나는지를 고려해야 한다.
 + 클러스터형 인덱스는 테이블당 하나만 생성할 수 있다.
   * 범위 검색에 아주 효울적임
 + 클러스터형 인덱스가 테이블에 아예 없는 것이 좋은 경우도 있다
 + 사용하지 않는 인덱스는 제거하자 
   * 주기적으로 OPTIMIZE TABLE 구문이나 ANALYZE TABLE 구문으로 인덱스를 재구성하자 
   